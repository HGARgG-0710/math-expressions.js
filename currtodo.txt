This file contains currently pursued TODOs and self-created tasks for the development of the library...; 

1 [main]. TODO [local; only in this file...]: Create all the infinite versions for all the finite [original] methods; 
For this, first make a list; 

Method list [to be generalized to the 'infinite' submodule; current list]: 

	'GeneralMatrix' (based off the GeneralArray)
	nonArrElems
	totalElems
	op
	repeatedOperation
	[Wait... Blast, it's all of them; Look further onto the line 15]

IDEA [for v1.1. to implement; maybe]: unite the 'infinite' and non-infinite methods using some manner of uniter-abstraction (for instance, use the CommonArray for the 'finite' cases?); 
	[Or maybe, v1.0?] There's just too many methods to be desireably separated for the two versions of these...
	It really is just mapping one architecture into another one, performing [essentially] the exactly same tasks; [Trivial, simply, boring...]; 
	How'd one accomplish this thing without all this ridiculous copy-paste? 
	Simple: generalize; How exactly, though? 
	One'd love to use the Infinite versions for this; 
	But it should still work with finite ones [The finite wrappers of the same form as those used within the 'infinite' would do the trick there]; 
	Next question becomes - how does this 'transform-unite transition' take its place on the minimum execution level?
	Is it performed manually by the user? (As in 'methodName(CommonArray(arrname)).array'?)
	
	It [the problem]'s really all about this 'conversion step'; Once it's been dealt with, the library might progress exceedingly smoothly...
	Problem lies in lack of unity of the architecture of Infinite part of the library and 'finite' native JS types used within the 'finite' part of 'math-expressions.js'

	IDEA [for a solution]: create a set of methods like: 
		
		function fi (fu) {
			return (x) => fu(CommonArray(x)).array	
		}
	
		These methods would, in self allow to do stuff like 'fi(Matrix)(...)'; 
		Which'd essentially solve the issues of: 
			
			1. Library being to 'heavy' with repeating methods; 
			2. Writing difficulties [twice the writing time for all this stuff...]; 
			3. Copying of the same architecture/funcitonality across the library; 
		
		As one'd desire to make this kind of thing 'general' (not merely the 'CommonArray' usage), one'd make something akin to: 

			function wrapper (in, out) {
				return (f) => ((x) => out(f(in(x))))
			}
		
		Which, then'd allow to define corresponding things with ease...
	
	Solves just about everything...
	Except for the stuff like 'IterableSet', which is really just finite versions of generalized objects' factories [far simpler (using native JS), yes, probably faster (using native JS), yes, but it's still FUNCTIONALLY, the same thing...]
		Should they [such things] be considered for keeping? Or not? 
		Is this REALLY an optimization matter? If so, does one want to consider it? If not, does one still wish to remove them? 
			This'd lead to a tremendous simplification of many of the library's aspects with simultaneuous concentration on the functional concerns rather than the possibilities of purely time/memory-cost nature...
			QUESTION IS: WOULD ONE LOVE THAT? 
			ANSWER IS: sure; So, the newly created conclusion, thus, is that: 

				About the reorganization procedures; 
					The distinction between which of the functions one desires to keep as native types insofar have been one, whose resolution is that of rather cloudy nature...
					Due to this, one will break up the reorganization of the 'finite' part of the library into two more steps: 
						1. putting ALL OF THEM [reworked] into the 'aliases.native', then finding out which doth and which doth not one desire to be kept within the library in their current state; 
						2. Then, generalizing one-by-one all of them, deleting the undesired finite versions... [with CommonArray, and other such generalized wrapper-types, one's able to have the PRECISE SAME behaviour as that of the non-general ones...]

				About the generalization specifics (plans): 
					The process of original development of the early versions of the math-expressions.js used to have been separated onto distinct steps; 
					This is why the current API is so very multi-directioned; 
					One ought to consider each and every part of it and what to do with it: 

						[THIS LIST SHOULD GET REVISED AFTER HAVING INTRODUCED THE STRUCTURAL CHANGES...]
						1. 'Equation' part:
							Not sure about generalizing this thing; 
							Problem is: it uses rational approximations for obtaining of solutions to given equations; 

							One could easily use the generalized UnlimitedString for the equations; 
							One could easily use the same thing for the varnames; 
							One could easily generalize the substitutions procedure; 

							The issue would be with the approximation. 
							HOW WELL DOTH ONE DESIRE FOR TO APPROXIMATE? 
							One could set a 'limit' to it...
							Or to approximate in layers...

							But then, comes the question of representation; 
							How does one represent it in the same fashion? [One that is printable]; 
							One'd want then the Printing class of some sorts; 
							[One could just outline the interface, then create some library-examples for it, maybe?]

							Yes, this is really-really nice...

							DECISION: yes. Do this work on them, pray; 

							The VarMapping gets replaced with the UnlimitedMap(s); 

						2. Abstract Native Structures [stuff like 'IterableSet' and object(and other native types')-related functions]: 
							The functions stay as a part of the 'aliases.native'; 
							Re-look through them and decide if one wants to take any of them out...
						3. Number-theoretic functions; 

							Things such as 'factorOut' or 'primes', for instance; 
							Should they be generalized? 
							Might get them to: 

								1. Use the GeneralArray [for the native-JS-Array-based functions]; 
								2. Use the InfiniteCounter for the integer-based/integer-related functions;
							
							There's a slight difficulty with something else... 
							The 'out-of-the-box' useage; One'd love it to be in place...

							Example: 

								With current 'factorOut', one goes ahead and and does 'console.log(factorOut(something))', with the corresponding array appearing in the output; 
								One'd love some manner of a Printing function for these [to have it all nice, pretty and configurable (general), to the potential liking of the user]; 

								Considerations for the 'Printing' API [Solved, largely]: 

									It ought to be able to interpret certain objects, by means of replacing of them with certain symbols in the out-stream...
									For instance, allow for a 'gate' function to be set on the way to a printing stream;
									Then, the question of API-specificness comes up; 

									One'd love this to work with BOTH the Deno and Node 'printing' APIs; 
									SOLUTION: the 'pfun' funciton for the actual printing is by default equal to the 'console.log', which is supported by the both of them;
									Then, in specific cicrumstances, one's able to replace it with something specific [for instance, in Node: process.stdout.write]; 

									Now, all one'd love to add to this is some manner of a default for outputting specifically the InfiniteCounter(s) and GeneralArray(s); 
									[With a 'printLimit' - the point at which'd one'd allow user to interject the process of printing [perhaps, for user input, or something else...]];

							HOWEVER...
							There is a further problem with this generalization's proceedings and that is - the non-integer part; 
							How should they be handled? 
							The problem becomes with the representation of things that get implemented: 

								For instance, logarithms or roots; 
								If they get defined, it should be in terms of corresponding power-functions; 
								Yet, generally, they don't HAVE to be belonging to the already decided InfiniteCounter-like domain [example: log_2(3)]; 
								So, what does one do about that? 

								Even if one DOES create a general data-based representation, which'd allow for inversing of the wrappers signifying the difference between a 'log/root' or a non-'log/root' number, 
								it'd still not help because one HAS NOT THE ACCESS TO THE INTERNAL REPRESENTATION; 
								Because it's not defined by means of the internal representation...

								One could delve into the infinite series;
								They'd work, sure; But does one really want to?  
								May it not be a more desireable thing for the user to do the implementation of all those technical subject-specific things? 

								The stuff one outlines here is generally useful [and because of it, 'pretty' - truly beautiful] because of the Integer's model; 
								An integer (here, InfiniteCounter) can correspond to very many things - an index, an amount, and so on... 
								The operations between them may be useful as a mean of obtaining of information about the external objects, with additional beauty packed within the chosen InfiniteCounter functions [the format of the counter chosen]; 

								The purely number-theoretic things lack that; 
								They are in-themselves, not generally concerned with any pure programming tasks; 
								CONCLUSION, thus, is such - they don't get added to the library [not in v1.0, at least, certainly not in it...]; 

								One does generalize the integer-related number-theoretic functions and tries not to have any ones that are not integer-related...

							About the finite versions: 
								Where do they go? 
								Decision: they'll be in the 'aliases.native.integers' submodule, which'll have the finite 'aliases', after having finished the generalization procedures for them; 
								Until then - the current originals...

	The outline of the current library version's structure's nigh finished!
	Now, all that's left is the linear part, hardcore alias-relinkage, small polishing and code-brushing, and testing-fixing! 

2 [side]. Code-brushing; Read code as you go along doing other things, make it 'tidier' and more liked; 
	2.1. Finish all the great amount of 'small' TODOs written all over the source code file; 
	2.2. Finish the finite methods; Create the stuff that was desired/planned but was not as of yet implemented within the library in question; 
	2.3. Re-view the older code, fix the leftover stuff from previous versions of the 'v1.0' version of the 'math-expressions.js'; 
	2.4. Fix the known bugs in advance; Look for them; 

3. DIRECTIONS: project is slowly entering a halting phase of development (again); 
	And again, due to lack of direction; 

		SOLUTION: one ought to be concentrating on TODOS in a methodological order. 
			Thus, one decides to do so - gather the list of all the presently pursued todos [not the 'todos.txt' kind], then work on each and every one of them; 
			One therefore must take some time to look through the old notes [again, make a list of todos for completion, do some little bit more of cleaning...]
		
	LIST OF CURRENTLY PURSUED TODOS: 
		[First off - the method of choice; The ones considered presently will all be of finishing/reparing/patching/fixing/generalizing/templatizing nature]
		1. Finish NumberEquation (based off the old Equation); 	
			1.1. First, simply understand the old method of work in detail, clean up, basic refactor, reconstruct it anew (with newly decided code practices); 
				1.1.1. The gist of it has been such - given a string being a sentence in a given language, the langauge is parsed and then converted to a two-side equation. 
						Then, one finds the difference of two sides and finds the values for variables that cause the difference to equal zero; 
						NOTE [1]: the thing works only with 1 sought variable - fix it? 
						The search is numerical purely and is done via manual substitution and decimal approximation; 
						NOTE [2]: this can only be limitedly useful and accurate. One ought to create and implement a class for unlimited decimals and decimal arithmetic; 
						After having computed an array of desired depth of accuracy and found the point of greatest accuracy, it is returned as an approximation for a solution; 
						NOTE [3]: doesn't seem to be taking account of the case of multiple possible answers; [If the case is that there are 2 or more equal smallest differences]
							So instead, return the array of them instaed;  
						NOTE [4]: two sides of the equation; 
							Approximation is currently taken via 'indexof(min|r-l|)'; 
							This strips the method of some degree of accuracy; 
							QUESTION: Make it so that it is possible to calulate it for both the sides [that is - there is the *signed* difference], or not? 
							ANSWER: currently - no; It doesn't give new information in regards of the minimal difference sought;  
						NOTE [5]: It appears to be using eval; Let it use library's 'op' API instead...

						Note [6]: When flesh wrote the code for this thing, it must have been half-asleep!

						NOTE [7]: The usage of finite strings; Again, as always with finite types - generalize to UnlimitedString [once having finally connected and defined it as an EXTENSION of the GeneralArray;]

			1.2. Then, generalize; 
		
		2. Finish the UnlimitedString; 
			([IN PARTICULAR] BEFORE DOING ANY OF THIS STUFF, PRAY RETHINK WHAT DOES ONE WANT THE UnlimitedString TO TRULY BE!)
			2.1. Repeatedly Validate throughout the development, solve upcoming definition issues...
			2.2. Main: 
				2.2.1. Make a list of new(added)/reworked(old, but redefined) methods for the UnlimitedString; 
				2.2.2. Consider which new methods from UnlimitedString should go into GeneralArray [and then, possibly redefined in UnlimitedString]; 

		3. Fix Self-References; 
			The library's self-references are extremely broken; Must be fixed...
		
		4. SIDETODO: Consider the system for the aliases [in particular, whether certain aliases should be handled outside the scope of the 'instance' function]; 
								IDEA: create another file within the library: 'lib.js'; 
								This file would contain the actual definitions, whereas the 'instance.js' would simply import from there, in order to provide structure for the library
									+ a powerful way of importing it...
								
		5. PROBLEM: with replacing the old API with the new General types: 
			While an Idea of supreme beauty from the standpoint of structural integrity and the computational range potential [reference to the unlimitedness of the types], 
				because of this transformation, the speed of the things may suffer greatly [namely, the numerous function calls]; 
			
			SO: before finally replacing all the 'Old' native-based apis with the general stuff, pray first ensure the difference in performance; 
				IF, it is considered by oneself too great, then keep the things under a new name [such as '.fast', for instance...]; 
				ELSE do as was previously decided; 

		6. Work on the Elementarization of all the library bits [abstraction from the 'instance' function]; 