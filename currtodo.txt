This file contains currently pursued TODOs and self-created tasks for the development of the library...; 

1 [main]. TODO [local; only in this file...]: Create all the infinite versions for all the finite [original] methods; 
For this, first make a list; 

Method list [to be generalized to the 'infinite' submodule; current list]: 

	'GeneralMatrix' (based off the GeneralArray)
	nonArrElems
	totalElems
	op
	repeatedOperation
	[Wait... Blast, it's all of them; Look further onto the line 15]

IDEA [for v1.1. to implement; maybe]: unite the 'infinite' and non-infinite methods using some manner of uniter-abstraction (for instance, use the CommonArray for the 'finite' cases?); 
	[Or maybe, v1.0?] There's just too many methods to be desireably separated for the two versions of these...
	It really is just mapping one architecture into another one, performing [essentially] the exactly same tasks; [Trivial, simply, boring...]; 
	How'd one accomplish this thing without all this ridiculous copy-paste? 
	Simple: generalize; How exactly, though? 
	One'd love to use the Infinite versions for this; 
	But it should still work with finite ones [The finite wrappers of the same form as those used within the 'infinite' would do the trick there]; 
	Next question becomes - how does this 'transform-unite transition' take its place on the minimum execution level?
	Is it performed manually by the user? (As in 'methodName(CommonArray(arrname)).array'?)
	
	It [the problem]'s really all about this 'conversion step'; Once it's been dealt with, the library might progress exceedingly smoothly...
	Problem lies in lack of unity of the architecture of Infinite part of the library and 'finite' native JS types used within the 'finite' part of 'math-expressions.js'

	IDEA [for a solution]: create a set of methods like: 
		
		function fi (fu) {
			return (x) => fu(CommonArray(x)).array	
		}
	
		These methods would, in self allow to do stuff like 'fi(Matrix)(...)'; 
		Which'd essentially solve the issues of: 
			
			1. Library being to 'heavy' with repeating methods; 
			2. Writing difficulties [twice the writing time for all this stuff...]; 
			3. Copying of the same architecture/funcitonality across the library; 
		
		As one'd desire to make this kind of thing 'general' (not merely the 'CommonArray' usage), one'd make something akin to: 

			function wrapper (in, out) {
				return (f) => ((x) => out(f(in(x))))
			}
		
		Which, then'd allow to define corresponding things with ease...
	
	Solves just about everything...
	Except for the stuff like 'IterableSet', which is really just finite versions of generalized objects' factories [far simpler (using native JS), yes, probably faster (using native JS), yes, but it's still FUNCTIONALLY, the same thing...]
		Should they [such things] be considered for keeping? Or not? 
		Is this REALLY an optimization matter? If so, does one want to consider it? If not, does one still wish to remove them? 
			This'd lead to a tremendous simplification of many of the library's aspects with simultaneuous concentration on the functional concerns rather than the possibilities of purely time/memory-cost nature...
			QUESTION IS: WOULD ONE LOVE THAT? 
			ANSWER IS: sure; So, the newly created conclusion, thus, is that: 
				1. All the contents of 'RESULT.classes' get to be generalized and turned into templated 'function-classes' (object-returning functions); 
				2. 'Result.clases' and 'Results.submodules.infinite' gets merged with 'Results.methods' into 'Results.main'; 
					The currently decided cretaed description of the merge procedure goes here... 

						The stuff from 'results.submodules.infinite' gets to generalize all the stuff from the 'finite' versions [thus, 'replaceing' and 'covering' them at the same time in the '.main' field]; 
						Each and every abstraction from 'native JS' used by the library gets generalized within the new 'results.submodules.infinite'; 

						[What about things like 'ensureProperty?'; They're extremely useful in both their variants (finite AND infinite) and the finite version gets used througout the library's code a lot...]; 
						For the cases, where one'd love to keep both the 'finite' and 'infinite' versions... 
						Let's consider various ways to implement this kind of 'localized' distinction: 	

							1. prefixes [nope; would be too many + too ugly + code repetition]; 
							2. separate structures [clumsy RESULT object; don't like it...]; 
							
						The problem comes down to identifying which particular *types* of functions are those that are desired to be kept in this particular fashion...
						CONCLUSION: all such functions are, in effect, really just aliases working with native types; 
						So, for instance, one could store those finite versions under 'RESULT.aliases.native'; 
						This way, there'd be 2 kinds of 'ensureProperty' [and other similarly defined functions] for both the native JS object type and a templated general InfiniteMap; 

					FURTHER CONCLUSION: about the reorganization procedures; 
						The distinction between which of the functions one desires to keep as native types insofar have been one, whose resolution is that of rather cloudy nature...
						Due to this, one will break up the reorganization of the 'finite' part of the library into two more steps: 
							1. putting ALL OF THEM [reworked] into the 'aliases.native', then finding out which doth and which doth not one desire to be kept within the library in their current state; 
							2. Then, generalizing one-by-one all of them, deleting the undesired finite versions... [with CommonArray, and other such generalized wrapper-types, one's able to have the PRECISE SAME behaviour as that of the non-general ones...]

				FURTHER CONCLUSION: 
					The process of original development of the early versions of the math-expressions.js used to have been separated onto distinct steps; 
					This is why the current API is so very multi-directioned; 
					One ought to consider each and every part of it and what to do with it: 

						[THIS LIST SHOULD GET REVISED AFTER HAVING INTRODUCED THE STRUCTURAL CHANGES...]
						1. 'Statistics' part (Statistics and Tests classes and all the related number-theoretic/statistics functions) [in progress]: 
							All this stuff gets generalized; 
							The names for the functions get to remain as a 'finite' special case (as in 'number()'); 

							It goes into the 'statistics' namespace; 

							But what to do about the number-theoretic functions? Should they be considered a part of this thing? 
							[No, one don't want to; They were developed largely independent of everything so one decides to consider them separate; Thus, they'll have their own namespace and a development punct...]
						2. VarMapping and 'Equation' part:
							Not sure about generalizing this thing; 
							Problem is: it uses rational approximations for obtaining of solutions to given equations; 

							One could easily use the generalized UnlimitedString for the equations; 
							One could easily use the same thing for the varnames; 
							One could easily generalize the substitutions procedure; 

							The issue would be with the approximation. 
							HOW WELL DOTH ONE DESIRE FOR TO APPROXIMATE? 
							One could set a 'limit' to it...
							Or to approximate in layers...

							But then, comes the question of representation; 
							How does one represent it in the same fashion? [One that is printable]; 
							One'd want then the Printing class of some sorts; 
							[One could just outline the interface, then create some library-examples for it, maybe?]

							Yes, this is really-really nice...

							DECISION: yes. Do this work on them, pray; 

						3. Algorithms part [along with the 'Ratio' class]: 
							'Algorithms' "static" class gets turned into an object structure for algorithms; 
							'Ratio' (maybe?) gets 'deleted' and becomes a label for the special case of the TrueRatio (one that uses finite 'number()'); 
								Only, first pray check for the functionality match between the two; If there is lack - finish the implementation of the corresponding algorithms on a more general level...
							What about generalizing the 'Algorithms'? Does one want to? 
						4. 'Linear' part [Matricies, Vectors]: 
							Generalize; 
							[Maybe] keep the names for those 'finite' versions as aliases; 
						5. Abstract Native Structures [stuff like 'IterableSet' and object(and other native types')-related functions]: 
							The functions stay as a part of the 'aliases.native'; 

	

2 [side]. Code-brushing; Read code as you go along doing other things, make it 'tidier' and more liked; 
	2.1. Decide what to do with the 'RESULT.classes' [should they get generalized or ought they be kept more or less the same way as before?]; 
	2.2. Decide what to do with the merging of 'RESULT.constants' and 'RESULT.globals' and 'RESULT.defaults' into something like 'RESULT.variables'; Decide about the 'variables' structure;
	2.3. Finish all the great amount of 'small' TODOs written all over the source code file; 
	2.4. Finish the finite methods; Create the stuff that was desired/planned but was not as of yet implemented within the library in question; 
	2.5. Re-view the older code, fix the leftover stuff from previous versions of the 'v1.0' version of the 'math-expressions.js'; 
	2.6. Fix the known bugs in advance; Look for them; 