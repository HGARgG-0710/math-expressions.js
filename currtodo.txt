This file contains currently pursued TODOs and self-created tasks for the development of the library...; 

1 [main]. TODO [local; only in this file...]: Create all the infinite versions for all the finite [original] methods; 
For this, first make a list; 

Method list [to be generalized to the 'infinite' submodule; current list]: 

	'GeneralMatrix' (based off the GeneralArray)
	nonArrElems
	totalElems
	op
	repeatedOperation
	[Wait... Blast, it's all of them; Look further onto the line 15]

IDEA [for v1.1. to implement; maybe]: unite the 'infinite' and non-infinite methods using some manner of uniter-abstraction (for instance, use the CommonArray for the 'finite' cases?); 
	[Or maybe, v1.0?] There's just too many methods to be desireably separated for the two versions of these...
	It really is just mapping one architecture into another one, performing [essentially] the exactly same tasks; [Trivial, simply, boring...]; 
	How'd one accomplish this thing without all this ridiculous copy-paste? 
	Simple: generalize; How exactly, though? 
	One'd love to use the Infinite versions for this; 
	But it should still work with finite ones [The finite wrappers of the same form as those used within the 'infinite' would do the trick there]; 
	Next question becomes - how does this 'transform-unite transition' take its place on the minimum execution level?
	Is it performed manually by the user? (As in 'methodName(CommonArray(arrname)).array'?)
	
	It [the problem]'s really all about this 'conversion step'; Once it's been dealt with, the library might progress exceedingly smoothly...
	Problem lies in lack of unity of the architecture of Infinite part of the library and 'finite' native JS types used within the 'finite' part of 'math-expressions.js'

	IDEA [for a solution]: create a set of methods like: 
		
		function fi (fu) {
			return (x) => fu(CommonArray(x)).array	
		}
	
		These methods would, in self allow to do stuff like 'fi(Matrix)(...)'; 
		Which'd essentially solve the issues of: 
			
			1. Library being to 'heavy' with repeating methods; 
			2. Writing difficulties [twice the writing time for all this stuff...]; 
			3. Copying of the same architecture/funcitonality across the library; 
		
		As one'd desire to make this kind of thing 'general' (not merely the 'CommonArray' usage), one'd make something akin to: 

			function wrapper (in, out) {
				return (f) => ((x) => out(f(in(x))))
			}
		
		Which, then'd allow to define corresponding things with ease...
	
	Solves just about everything...
	Except for the stuff like 'IterableSet', which is really just finite versions of generalized objects' factories [far simpler (using native JS), yes, probably faster (using native JS), yes, but it's still FUNCTIONALLY, the same thing...]
		Should they [such things] be considered for keeping? Or not? 
		Is this REALLY an optimization matter? If so, does one want to consider it? If not, does one still wish to remove them? 
			This'd lead to a tremendous simplification of many of the library's aspects with simultaneuous concentration on the functional concerns rather than the possibilities of purely time/memory-cost nature...
			QUESTION IS: WOULD ONE LOVE THAT? 
			ANSWER IS: sure; So, the newly created conclusion, thus, is that: 
				1. All the contents of 'RESULT.classes' get to be generalized and turned into templated 'function-classes' (object-returning functions); 
				2. 'Result.clases' and 'Results.submodules.infinite' gets merged with 'Results.methods' into 'Results.main'; 
					The currently decided cretaed description of the merge procedure goes here... 

						The stuff from 'results.submodules.infinite' gets to generalize all the stuff from the 'finite' versions [thus, 'replaceing' and 'covering' them at the same time in the '.main' field]; 
						Each and every abstraction from 'native JS' used by the library gets generalized within the new 'results.submodules.infinite'; 

						[What about things like 'ensureProperty?'; They're extremely useful in both their variants (finite AND infinite) and the finite version gets used througout the library's code a lot...]; 
						For the cases, where one'd love to keep both the 'finite' and 'infinite' versions... 
						Let's consider various ways to implement this kind of 'localized' distinction: 	

							1. prefixes [nope; would be too many + too ugly + code repetition]; 
							2. separate structures [clumsy RESULT object; don't like it...]; 
							
						The problem comes down to identifying which particular *types* of functions are those that are desired to be kept in this particular fashion...
						CONCLUSION: all such functions are, in effect, really just aliases working with native types; 
						So, for instance, one could store those finite versions under 'RESULT.aliases.native'; 
						This way, there'd be 2 kinds of 'ensureProperty' [and other similarly defined functions] for both the native JS object type and a templated general InfiniteMap; 

					FURTHER CONCLUSION: about the reorganization procedures; 
						The distinction between which of the functions one desires to keep as native types insofar have been one, whose resolution is that of rather cloudy nature...
						Due to this, one will break up the reorganization of the 'finite' part of the library into two more steps: 
							1. putting ALL OF THEM [reworked] into the 'aliases.native', then finding out which doth and which doth not one desire to be kept within the library in their current state; 
							2. Then, generalizing one-by-one all of them, deleting the undesired finite versions... [with CommonArray, and other such generalized wrapper-types, one's able to have the PRECISE SAME behaviour as that of the non-general ones...]
	

2 [side]. Code-brushing; Read code as you go along doing other things, make it 'tidier' and more liked; 
	2.1. Decide what to do with the 'RESULT.classes' [should they get generalized or ought they be kept more or less the same way as before?]; 
	2.2. Decide what to do with the merging of 'RESULT.constants' and 'RESULT.globals' and 'RESULT.defaults' into something like 'RESULT.variables'; Decide about the 'variables' structure;
	2.3. Finish the work on the 'Surface' class; 
	2.4. Finish all the great amount of 'small' TODOs written all over the source code file; 
	2.5. Finish the finite methods; Create the stuff that was desired/planned but was not as of yet implemented within the library in question; 
	2.6. Re-view the older code, fix the leftover stuff from previous versions of the 'v1.0' version of the 'math-expressions.js'; 