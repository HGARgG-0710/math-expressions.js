This file contains currently pursued TODOs and self-created tasks for the development of the library...; 

1 [main]. TODO [local; only in this file...]: Create all the infinite versions for all the finite [original] methods; 
For this, first make a list; 

Method list [to be generalized to the 'infinite' submodule; current list]: 

	'GeneralMatrix' (based off the GeneralArray)
	nonArrElems
	totalElems
	op
	repeatedOperation
	[Wait... Blast, it's all of them; Look further onto the line 15]

IDEA [for v1.1. to implement; maybe]: unite the 'infinite' and non-infinite methods using some manner of uniter-abstraction (for instance, use the CommonArray for the 'finite' cases?); 
	[Or maybe, v1.0?] There's just too many methods to be desireably separated for the two versions of these...
	It really is just mapping one architecture into another one, performing [essentially] the exactly same tasks; [Trivial, simply, boring...]; 
	How'd one accomplish this thing without all this ridiculous copy-paste? 
	Simple: generalize; How exactly, though? 
	One'd love to use the Infinite versions for this; 
	But it should still work with finite ones [The finite wrappers of the same form as those used within the 'infinite' would do the trick there]; 
	Next question becomes - how does this 'transform-unite transition' take its place on the minimum execution level?
	Is it performed manually by the user? (As in 'methodName(CommonArray(arrname)).array'?)
	
	It [the problem]'s really all about this 'conversion step'; Once it's been dealt with, the library might progress exceedingly smoothly...
	Problem lies in lack of unity of the architecture of Infinite part of the library and 'finite' native JS types used within the 'finite' part of 'math-expressions.js'

	IDEA [for a solution]: create a set of methods like: 
		
		function fi (fu) {
			return (x) => fu(CommonArray(x)).array	
		}
	
		These methods would, in self allow to do stuff like 'fi(Matrix)(...)'; 
		Which'd essentially solve the issues of: 
			
			1. Library being to 'heavy' with repeating methods; 
			2. Writing difficulties [twice the writing time for all this stuff...]; 
			3. Copying of the same architecture/funcitonality across the library; 
		
		As one'd desire to make this kind of thing 'general' (not merely the 'CommonArray' usage), one'd make something akin to: 

			function wrapper (in, out) {
				return (f) => ((x) => out(f(in(x))))
			}
		
		Which, then'd allow to define corresponding things with ease...
	
	Solves just about everything...
	Except for the stuff like 'IterableSet', which is really just finite versions of generalized objects' factories [far simpler (using native JS), yes, probably faster (using native JS), yes, but it's still FUNCTIONALLY, the same thing...]
		Should they [such things] be considered for keeping? Or not? 
		Is this REALLY an optimization matter? If so, does one want to consider it? If not, does one still wish to remove them? 
			This'd lead to a tremendous simplification of many of the library's aspects with simultaneuous concentration on the functional concerns rather than the possibilities of purely time/memory-cost nature...
			QUESTION IS: WOULD ONE LOVE THAT? 
			ANSWER IS: sure; So, the newly created conclusion, thus, is that: 
				1. All the contents of 'RESULT.classes' get to be generalized and turned into templated 'function-classes' (object-returning functions); 
				2. 'Result.clases' and 'Results.submodules.infinite' gets merged with 'Results.methods' into 'Results.main'; 
					The currently decided cretaed description of the merge procedure goes here... 

						The stuff from 'results.submodules.infinite' gets to generalize all the stuff from the 'finite' versions [thus, 'replaceing' and 'covering' them at the same time in the '.main' field]; 
						Each and every abstraction from 'native JS' used by the library gets generalized within the new 'results.submodules.infinite'; 

						[What about things like 'ensureProperty?'; They're extremely useful in both their variants (finite AND infinite) and the finite version gets used througout the library's code a lot...]; 
						For the cases, where one'd love to keep both the 'finite' and 'infinite' versions... 
						Let's consider various ways to implement this kind of 'localized' distinction: 	

							1. prefixes [nope; would be too many + too ugly + code repetition]; 
							2. separate structures [clumsy RESULT object; don't like it...]; 
							
						The problem comes down to identifying which particular *types* of functions are those that are desired to be kept in this particular fashion...
						CONCLUSION: all such functions are, in effect, really just aliases working with native types; 
						So, for instance, one could store those finite versions under 'RESULT.aliases.native'; 
						This way, there'd be 2 kinds of 'ensureProperty' [and other similarly defined functions] for both the native JS object type and a templated general InfiniteMap; 

					FURTHER CONCLUSION: about the reorganization procedures; 
						The distinction between which of the functions one desires to keep as native types insofar have been one, whose resolution is that of rather cloudy nature...
						Due to this, one will break up the reorganization of the 'finite' part of the library into two more steps: 
							1. putting ALL OF THEM [reworked] into the 'aliases.native', then finding out which doth and which doth not one desire to be kept within the library in their current state; 
							2. Then, generalizing one-by-one all of them, deleting the undesired finite versions... [with CommonArray, and other such generalized wrapper-types, one's able to have the PRECISE SAME behaviour as that of the non-general ones...]

				FURTHER CONCLUSION: 
					The process of original development of the early versions of the math-expressions.js used to have been separated onto distinct steps; 
					This is why the current API is so very multi-directioned; 
					One ought to consider each and every part of it and what to do with it: 

						[THIS LIST SHOULD GET REVISED AFTER HAVING INTRODUCED THE STRUCTURAL CHANGES...]
						1. 'statistics' part (Statistics and Tests classes and all the related statistics functions) [in progress]: 
							All this stuff gets generalized; 
							The names for the functions get to remain as a 'finite' special case (as in 'number()'); 
							It goes into the 'statistics' namespace; 

						2. 'Equation' part:
							Not sure about generalizing this thing; 
							Problem is: it uses rational approximations for obtaining of solutions to given equations; 

							One could easily use the generalized UnlimitedString for the equations; 
							One could easily use the same thing for the varnames; 
							One could easily generalize the substitutions procedure; 

							The issue would be with the approximation. 
							HOW WELL DOTH ONE DESIRE FOR TO APPROXIMATE? 
							One could set a 'limit' to it...
							Or to approximate in layers...

							But then, comes the question of representation; 
							How does one represent it in the same fashion? [One that is printable]; 
							One'd want then the Printing class of some sorts; 
							[One could just outline the interface, then create some library-examples for it, maybe?]

							Yes, this is really-really nice...

							DECISION: yes. Do this work on them, pray; 

							The VarMapping gets replaced with the UnlimitedMap(s); 

						3. algorithms part: 
							Generalize the Algorithms [in particular the 'Farey' sequence and the Ratio-TrueRatio replacement...]; 
						4. 'Linear' part [Matricies, Vectors]: 
							Generalize; 
							[Maybe] keep the names for those 'finite' versions as aliases; 
						5. Abstract Native Structures [stuff like 'IterableSet' and object(and other native types')-related functions]: 
							The functions stay as a part of the 'aliases.native'; 
							Re-look through them and decide if one wants to take any of them out...
						6. Number-theoretic functions; 

							Things such as 'factorOut', for instance; 
							Should they be generalized? 
							Might get them to: 

								1. Use the GeneralArray [for the native-JS-Array-based functions]; 
								2. Use the InfiniteCounter for the integer-based/integer-related functions;
							
							There's a slight difficulty with something else... 
							The 'out-of-the-box' useage; One'd love it to be in place...

							Example: 

								With current 'factorOut', one goes ahead and and does 'console.log(factorOut(something))', with the corresponding array appearing in the output; 
								One'd love some manner of a Printing function for these [to have it all nice, pretty and configurable (general), to the potential liking of the user]; 

								Considerations for the 'Printing' API [Solved, largely]: 

									It ought to be able to interpret certain objects, by means of replacing of them with certain symbols in the out-stream...
									For instance, allow for a 'gate' function to be set on the way to a printing stream;
									Then, the question of API-specificness comes up; 

									One'd love this to work with BOTH the Deno and Node 'printing' APIs; 
									SOLUTION: the 'pfun' funciton for the actual printing is by default equal to the 'console.log', which is supported by the both of them;
									Then, in specific cicrumstances, one's able to replace it with something specific [for instance, in Node: process.stdout.write]; 

									Now, all one'd love to add to this is some manner of a default for outputting specifically the InfiniteCounter(s) and GeneralArray(s); 
									[With a 'printLimit' - the point at which'd one'd allow user to interject the process of printing [perhaps, for user input, or something else...]];

							HOWEVER...
							There is a further problem with this generalization's proceedings and that is - the non-integer part; 
							How should they be handled? 
							The problem becomes with the representation of things that get implemented: 

								For instance, logarithms or roots; 
								If they get defined, it should be in terms of corresponding power-functions; 
								Yet, generally, they don't HAVE to be belonging to the already decided InfiniteCounter-like domain [example: log_2(3)]; 
								So, what does one do about that? 

								Even if one DOES create a general data-based representation, which'd allow for inversing of the wrappers signifying the difference between a 'log/root' or a non-'log/root' number, 
								it'd still not help because one HAS NOT THE ACCESS TO THE INTERNAL REPRESENTATION; 
								Because it's not defined by means of the internal representation...

								One could delve into the infinite series;
								They'd work, sure; But does one really want to?  
								May it not be a more desireable thing for the user to do the implementation of all those technical subject-specific things? 

								The stuff one outlines here is generally useful [and because of it, 'pretty' - truly beautiful] because of the Integer's model; 
								An integer (here, InfiniteCounter) can correspond to very many things - an index, an amount, and so on... 
								The operations between them may be useful as a mean of obtaining of information about the external objects, with additional beauty packed within the chosen InfiniteCounter functions [the format of the counter chosen]; 

								The purely number-theoretic things lack that; 
								They are in-themselves, not generally concerned with any pure programming tasks; 
								CONCLUSION, thus, is such - they don't get added to the library [not in v1.0, at least, certainly not in it...]; 

								One does generalize the integer-related number-theoretic functions and tries not to have any ones that are not integer-related...

							About the finite versions: 
								Where do they go? 
								Decision: they'll be in the 'aliases.native.integers' submodule, which'll have the finite 'aliases', after having finished the generalization procedures for them; 
								Until then - the current originals...
	

1.1. THE OUTLINE OF THE LIBRARY STRUCTURE [compilation]: 

	As a result of comprehension that the previous 1.0 note was slightly too confused now, one's redoing it as a single note... 

		RESULT: {
			main: {
				// 'Main' stuff - functions and classes, categorized by general objects sometimes
			}, 
			variables: {
				// 'Get-set'-type object-variables go here...
			}, 
			aliases: {
				// ? question: rename to 'types' instead? 
				native: {
					// Stuff related to native types aliases
					// Separates onto : 

						string: {}, 
						array: {}, 
						object: {}, 
						number: {
							integer: {
								// Subset of '.number' related to simple yet powerful number-theoretic integer-related stuff...
							}
						},
						function: {}, 
						boolean: {}
				}
				// Stuff that is pure aliases to 'main', or very things general like 'id' or 'refCompare', which don't fit in with the '.types' (.native) field...
			}
		}

2 [side]. Code-brushing; Read code as you go along doing other things, make it 'tidier' and more liked; 
	2.1. Decide what to do with the 'RESULT.classes' [should they get generalized or ought they be kept more or less the same way as before?]; 
	2.2. Decide what to do with the merging of 'RESULT.constants' and 'RESULT.globals' and 'RESULT.defaults' into something like 'RESULT.variables'; Decide about the 'variables' structure;
	2.3. Finish all the great amount of 'small' TODOs written all over the source code file; 
	2.4. Finish the finite methods; Create the stuff that was desired/planned but was not as of yet implemented within the library in question; 
	2.5. Re-view the older code, fix the leftover stuff from previous versions of the 'v1.0' version of the 'math-expressions.js'; 
	2.6. Fix the known bugs in advance; Look for them; 