? Question: define the InfiniteArray's true image as a special case for InfiniteMap? 

InfiniteArray<
	defaultgenerator
	defaultcomparison
	pushback(thing) // add to the end
	pushfront(thing) // add to the beginning
	index<generator=defaultgenerator, comparison=defaultcomparison>(_index) // returns thing at a given index; [uses generator to get new indexes and 'comparison' to 'compare' with the given index, checking for the element...]
	delete<generator=defaultgenerator>(index) // deletes at an appropriate index, with appropriate generator
	[Symbol.iterator]
	forin(body) // for-in construction
	reverse()
	map()
	sort(pred) 
	length() // length function
	concat(infarr) // concatenate with another infinitearray [question -- should this thing be templated as well?]
	copyWithin<generator>(beginind, endind, targetind) // like Array.copyWithin(), but 0th argument becomes 2nd and the 'endind' is inclusive; 
	every(func) // like Array.every(); min(Array.map(boolmapfunction))
	any(func) // max(Array.map(boolmapfunction))
	reduce(initial, direction, callback) [like Array.reduce(), under question?] // 'direction' would correspond to 'the way' that this thing is working: generalized reduce/reduceRight
	slice<generator>(start, end) // uses the generator; same as Array.slice(), but both indexes are inclusive
	[filter/property]() // like Array.filter()
	indexesOf<comparison=defaultcomparison, generator>(ele) // generalized of Array.indexOf(), and Array.lastIndexOf() -- uses 'generator' to create indexes and 'comparison' to check for given element[?s array?] 'ele'; 
	entries<generator=defaultgenerator>() // same as Array.entries, but uses 'generator' for indexes
	each<generator=defaultgenerator>((ind, el, arr) => {...}) // same as Array.forEach()
	fillfrom<generator=defaultgenerator, comparison>(index, value) // fills the array from the one moment when the given 'generator' becomes 'comparable' to the 'value'; 
> (array) {}


TODO: pray do, after having created the 'Order'-like [or generator/InfiniteArray-like] variable for the InfiniteMap (to provide with the other InfinteArray's methods [id est, make them equivalent...])
Then, one would simply define the 'InfiniteArray' as InfiniteMap *without* that order-like argument and that's it! 
CURRENT AGENDA: decide what kind of a structure to add to InfiniteMap for these kinds of things, think more about what stuff it should have...
InfiniteMap<
	set<comparison>(key, value)
	get<comparison>(key)
	entries<generator>() // like Object.entries()
	map((value, key, obj) => [newvalue, newkey]) // Maps a map to a map. 
	every((value, key) => boolean) // same as Array.
	[Symbol.iterator]
	>([keys, objects] or some: InfiniteMap or map: {})

IDEA: ?separate the 'infinite' onto 'wrapper/abstract' and 'content/particular'? 
InfiniteArray would be in abstract, whilst stuff like numberCounter or lastIndexArray -- in particular. 

Idea: 'order' is just a function for ordering an infinite array of things [from one infinite array generated by a function to another infinite array!]; 
Namely, it would take a value of another function, which would be some such 'index-generator' [perhaps, one that is used by the InfiniteMap already?]
Problem: one don't get to use InfiniteMap to define the InfiniteArray, rather using InfiniteArray to define the InfiniteMap; Rather, the reverse...
Decision: so, let it be...

Question: if one DOES base one's [general] InfiniteMap upon general InfiniteArray, why not base the particular cases of the InfiniteMap on InfiniteArray [another template, then???]? 

IDEA: implement a 'convert' method for various such 'template' things; Let it do the next thing -- translate one template object into another; 
??Work on a general matter of templates??

IDEA: add a method indexes() to the InfiniteArray; Let it return all the indexes present within the array in question...
It'd work useing the 'generator' template parameter...

IDEA: add a method to the InfiniteArray for deleting by property [instead of an index -- generalized version...]; 

IDEA: for an ACTUALLY infinite string (not just 'programmatically unlimited', actually infinite!); 
Only problem is -- the possible amount of it that can be read is STILL finite :D, but the string itself is infinite! 
Idea is such -- have a set of functions-counter pairs ".fcps", of which one is taking any array equivalent of the form [(f1, c1), (f2, c2), ...]; 
With 'counters' representing the one state to which the function in question have in fact gone to; 
To read the string, functions are called consequently to return the current index (also InfiniteCounter) of the string in question; 
if it is 'greater' than the one that is currently read, one skips the function in question, gets to the next one! 
This way, one gets the string 'symbol-by-symbol', after having 'found' the current index, one sets the corresponding counter for the corresponding function and starts search from there! 

So long as the infinite string in question can be represented with the use of the elementary functions of the counter model in question, one can store it in a finite amount of memory! 
Beautiful! [note also, that the InfiniteCounters in question must also be programmatically unlimited, so doing this stuff with finite integers won't really work; one only gets the usual string]; 

So, [idea] rename the what is currently the 'InfiniteString' within the library into 'UnlimitedString', and 'InfiniteString' will then be this thing! 

? Question: Do something similar about the matter of the InfiniteCounters [they become UnlimitedCounters]? 
But, then... What is an 'infinite' counter? Here, an 'infinite' string means that it has [literally] got an infinite length;
* Current decision: no; 

? Question: about InfiniteArrays -- why, one could do just the same thing there, no? 
Have it set by a function, changing an index via some 'comparison' means re-initializing the function into the wrapping of the thing in question into another function; 
! Problem: Stack; This would work if it was done in continuation-passing style, but as [currently] the library isn't, this wouldn't really work to allow infinite change of the thing...; 
* Current decision: add the thing described here, think about the name a bit more 
[either add it under this name only into the continuation-passing style version of the library, or in the other version make a disclaimer that it's a 'mostly read'-kind-of structure]; 

? Question: same-same-same about the InfiniteMap -- have one function for the keys, one function for the values and one index generator; 

The user could always change the Array's function, of course...
but the library has no way of doing it the same way as the user -- that'd require [at least]
parsing the function, then putting in the new AST at its beginning, 
then 'compile' to a function back again and then replacing the result for the original function; 
? Though, perhaps, one would do that [with the use of a different library of oneselves']???

^ NOTE: the InfiniteString has the exact same difficulty -- unless either the user changes the functions themselves [which is direct user's interation...], 
the library learns to parse functions of arbitrary finite length [perhaps with the use of a different library of oneself], 
or one does everything in a continuation-passing style [+ corresponding structure for infinte stack implementation, which is a different part of the library...], 
one has no way to allow infinite change of the infinite string/infinite array/infinite map 
[which is 'sort of' different from a finite string [they don't change, JS just creates new ones]; and is completely different from ]; 

NOTICED ANOTHER PROBLEM: the 'Infinite' types within the library, that are based on recursive array/object types depend on the size of the JS stack; 
As it isn't [by default] infinite [one writes the implementation separately], they aren't REALLY unlimited 
[or, more precisely, though the types themselves ARE unlimited, they can't be USED as types that are, in fact, unlimited]; 
This means that one does [certainly] get to write the infinite stack implementation of that thing...
Question: should the library then be 'united' with the other library of self's that does provide this functionality? 

AGAIN, the question of library-management and 'how-to-import-best?';
Pray think on it; 
For continuation, follow 'privatenotes.txt' [continuation 1]

BREAK 

NOW.... whilst starting the implementation of the LastIndexArray and the DeepArray, one thought whether it would not be better if the algorithms used for them were separate as well... 
But then, comes the questions of: 

	1. naming and notation; 
	2. library organization; 

Because: 

	1. one don't want long ugly names like those that are there already and one don't want short uncomprehensible ones [id est, create the single naming convention for this library version...]
	2. one don't want to clutter the 'infinite' object with them - perhaps, better make a property of it which would be a subobject for 'algorithms', containing those?

So, for example, one could do 'infinite.algorithms.arrays.lastIndexArrConcat(..., ...)'; 