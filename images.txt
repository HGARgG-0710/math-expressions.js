One revisits this file to use it as a sort of short todo-list...

GeneralArray<> (array) {
	copyWithin<generator>(beginind, endind, targetind) // like Array.copyWithin(), but 0th argument becomes 2nd and the 'endind' is inclusive; 
	reduce(initial, direction, callback) [like Array.reduce(), under question?] // 'direction' would correspond to 'the way' that this thing is working: generalized reduce/reduceRight
	entries<generator=defaultgenerator>() // same as Array.entries, but uses 'generator' for indexes; Note: doesn't 'loop' already do that?
}

UnlimitedMap<
	entries<generator>() // like Object.entries()
	map((value, key, obj) => [newvalue, newkey]) // Maps a map to a map. 
	every((value, key) => boolean) // same as Array.
	[Symbol.iterator]
	>([keys, objects] or some: InfiniteMap or map: {})

About InfiniteArray function-replacement and stack-usage: 

	The user could always change the Array's function, of course...
	but the library has no way of doing it the same way as the user -- that'd require [at least]
	parsing the function, then putting in the new AST at its beginning, 
	then 'compile' to a function back again and then replacing the result for the original function; 
	? Though, perhaps, one would do that [with the use of a different library of oneselves']???
	
	In the returnless version, this wouldn't be an issue due to a Stack unlimitation (so, if implement, then do it later...). 
	
Question: should the library then be 'united' with the other library of self's that does provide the functionality for the returnless stack? 
