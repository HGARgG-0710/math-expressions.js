? Question: define the InfiniteArray's true image as a special case for InfiniteMap? 

InfiniteArray<
	defaultgenerator
	defaultcomparison
	pushback(thing) // add to the end
	pushfront(thing) // add to the beginning
	index<generator=defaultgenerator, comparison=defaultcomparison>(_index) // returns thing at a given index; [uses generator to get new indexes and 'comparison' to 'compare' with the given index, checking for the element...]
	delete<generator=defaultgenerator>(index) // deletes at an appropriate index, with appropriate generator
	[Symbol.iterator]
	forin(body) // for-in construction
	reverse()
	map()
	sort(pred) 
	length() // length function
	concat(infarr) // concatenate with another infinitearray [question -- should this thing be templated as well?]
	copyWithin<generator>(beginind, endind, targetind) // like Array.copyWithin(), but 0th argument becomes 2nd and the 'endind' is inclusive; 
	every(func) // like Array.every(); min(Array.map(boolmapfunction))
	any(func) // max(Array.map(boolmapfunction))
	reduce(initial, direction, callback) [like Array.reduce(), under question?] // 'direction' would correspond to 'the way' that this thing is working: generalized reduce/reduceRight
	slice<generator>(start, end) // uses the generator; same as Array.slice(), but both indexes are inclusive
	[filter/property]() // like Array.filter()
	indexesOf<comparison=defaultcomparison, generator>(ele) // generalized of Array.indexOf(), and Array.lastIndexOf() -- uses 'generator' to create indexes and 'comparison' to check for given element[?s array?] 'ele'; 
	entries<generator=defaultgenerator>() // same as Array.entries, but uses 'generator' for indexes
	each<generator=defaultgenerator>((ind, el, arr) => {...}) // same as Array.forEach()
	fillfrom<generator=defaultgenerator, comparison>(index, value) // fills the array from the one moment when the given 'generator' becomes 'comparable' to the 'value'; 
> (array) {}


TODO: pray do, after having created the 'Order'-like [or generator/InfiniteArray-like] variable for the InfiniteMap (to provide with the other InfinteArray's methods [id est, make them equivalent...])
Then, one would simply define the 'InfiniteArray' as InfiniteMap *without* that order-like argument and that's it! 
CURRENT AGENDA: decide what kind of a structure to add to InfiniteMap for these kinds of things, think more about what stuff it should have...
InfiniteMap<
	set<comparison>(key, value)
	get<comparison>(key)
	entries<generator>() // like Object.entries()
	map((value, key, obj) => [newvalue, newkey]) // Maps a map to a map. 
	every((value, key) => boolean) // same as Array.
	[Symbol.iterator]
	>([keys, objects] or some: InfiniteMap or map: {})

IDEA: ?separate the 'infinite' onto 'wrapper/abstract' and 'content/particular'? 
InfiniteArray would be in abstract, whilst stuff like numberCounter or lastIndexArray -- in particular. 

Idea: 'order' is just a function for ordering an infinite array of things [from one infinite array generated by a function to another infinite array!]; 
Namely, it would take a value of another function, which would be some such 'index-generator' [perhaps, one that is used by the InfiniteMap already?]
Problem: one don't get to use InfiniteMap to define the InfiniteArray, rather using InfiniteArray to define the InfiniteMap; Rather, the reverse...
Decision: so, let it be...

Question: if one DOES base one's [general] InfiniteMap upon general InfiniteArray, why not base the particular cases of the InfiniteMap on InfiniteArray [another template, then???]? 

IDEA: implement a 'convert' method for various such 'template' things; Let it do the next thing -- translate one template object into another; 
??Work on a general matter of templates??

IDEA: add a method indexes() to the InfiniteArray; Let it return all the indexes present within the array in question...
It'd work useing the 'generator' template parameter...

IDEA: add a method to the InfiniteArray for deleting by property [instead of an index -- generalized version...]; 

IDEA: for an ACTUALLY infinite string (not just 'programmatically unlimited', actually infinite!); 
Only problem is -- the possible amount of it that can be read is STILL finite :D, but the string itself is infinite! 
Idea is such -- have a set of functions-counter pairs ".fcps", of which one is taking any array equivalent of the form [(f1, c1), (f2, c2), ...]; 
With 'counters' representing the one state to which the function in question have in fact gone to; 
To read the string, functions are called consequently to return the current index (also InfiniteCounter) of the string in question; 
if it is 'greater' than the one that is currently read, one skips the function in question, gets to the next one! 
This way, one gets the string 'symbol-by-symbol', after having 'found' the current index, one sets the corresponding counter for the corresponding function and starts search from there! 
After-Note [forgotten to document]: Each such a set is given to a certain symbol from the encoding chosen [or, if that was the originally intended way for it...] the COUNTERS represent the letters!; 

ALTERNATIVE IMPLEMENTATION [simpler, similar idea]: just map an index-function to each symbol of the charset, then add a way for the user to 'compare' the indexes in question, 
then just 'seek' in the same fashion.  

So long as the infinite string in question can be represented with the use of the elementary functions of the counter model in question, one can store it in a finite amount of memory! 
Beautiful! [note also, that the InfiniteCounters in question must also be programmatically unlimited, so doing this stuff with finite integers won't really work; one only gets the usual string]; 

So, [idea] rename the what is currently the 'InfiniteString' within the library into 'UnlimitedString', and 'InfiniteString' will then be this thing! 

? Question: Do something similar about the matter of the InfiniteCounters [they become UnlimitedCounters]? 
But, then... What is an 'infinite' counter? Here, an 'infinite' string means that it has [literally] got an infinite length;
* Current decision: no; 

? Question: about InfiniteArrays -- why, one could do just the same thing there, no? 
Have it set by a function, changing an index via some 'comparison' means re-initializing the function into the wrapping of the thing in question into another function; 
! Problem: Stack; This would work if it was done in continuation-passing style, but as [currently] the library isn't, this wouldn't really work to allow infinite change of the thing...; 
* Current decision: add the thing described here, think about the name a bit more 
[either add it under this name only into the continuation-passing style version of the library, or in the other version make a disclaimer that it's a 'mostly read'-kind-of structure]; 

? Question: same-same-same about the InfiniteMap -- have one function for the keys, one function for the values and one index generator; 

The user could always change the Array's function, of course...
but the library has no way of doing it the same way as the user -- that'd require [at least]
parsing the function, then putting in the new AST at its beginning, 
then 'compile' to a function back again and then replacing the result for the original function; 
? Though, perhaps, one would do that [with the use of a different library of oneselves']???

^ NOTE: the InfiniteString has the exact same difficulty -- unless either the user changes the functions themselves [which is direct user's interation...], 
the library learns to parse functions of arbitrary finite length [perhaps with the use of a different library of oneself], 
or one does everything in a continuation-passing style [+ corresponding structure for infinte stack implementation, which is a different part of the library...], 
one has no way to allow infinite change of the infinite string/infinite array/infinite map 
[which is 'sort of' different from a finite string [they don't change, JS just creates new ones]; and is completely different from ]; 

NOTICED ANOTHER PROBLEM: the 'Infinite' types within the library, that are based on recursive array/object types depend on the size of the JS stack; 
As it isn't [by default] infinite [one writes the implementation separately], they aren't REALLY unlimited 
[or, more precisely, though the types themselves ARE unlimited, they can't be USED as types that are, in fact, unlimited]; 
This means that one does [certainly] get to write the infinite stack implementation of that thing...
Question: should the library then be 'united' with the other library of self's that does provide this functionality? 

AGAIN, the question of library-management and 'how-to-import-best?';
Pray think on it; 
For continuation, follow 'privatenotes.txt' [continuation 1]

BREAK 

NOW.... whilst starting the implementation of the LastIndexArray and the DeepArray, one thought whether it would not be better if the algorithms used for them were separate as well... 
But then, comes the questions of: 

	1. naming and notation; 
	2. library organization; 

Because: 

	1. one don't want long ugly names like those that are there already and one don't want short uncomprehensible ones [id est, create the single naming convention for this library version...]
	2. one don't want to clutter the 'infinite' object with them - perhaps, better make a property of it which would be a subobject for 'algorithms', containing those?

So, for example, one could do 'infinite.algorithms.arrays.lastIndexArrConcat(..., ...)'; 



! PROBLEM: this idea, however beautiful, don't seem to 
IterArray <begin, generator, inversegenerator>{
	array
	[private?] currindex = begin
	// decreases index
	previous() {
		this.currindex = [this.]inversegenerator(currindex)
	}
	// increases index
	next() {
		this.currindex = [this.]generator(currindex)
	}
	setcurr(value) // sets new value to current index
}

// * Note: this will still require more of the elements of the template -- stuff like 'isUndefined' and so on...
GeneralArray <begin, indexgenerator, inverseindexgenerator, comparison, undefinedSymbol> {
	[...all the other general algorithms go here...]	
	iterarray <- IterArray<begin, indexgenerator, inverseindexgenerator>
	// These three sketches for algorithms make it possible to define everything else in terms of them generally... 
	read(index) {
		let curr = [this.]undefinedSymbol
		let currElem = [this.]begin
		while (!comparison(curr = indexgenerator(curr), index))
			currElem = this.iterarray.next()	
		return currElem
	}
	write(index, value) {	
		let curr = [this.]undefinedSymbol
		while (!comparison(curr = [this.]indexgenerator(curr), index)){}	
		this.iterarray.setcurr(value)
	}
}

// ^ THE BEAUTY OF IT : all the recursive part is taken by the 'IterArray', whilst the GeneralArray [or 'UnlimitedArray', better?], only contains flat algorithms, working with indexes and generators and comparisons and such. 
That is what it is -- a generalization. 
The iterations and inner index-representations are handled fully by the 'IterArray's. 
PROBLEM: the 'currindex' thing. If it is finite, then this don't actually work...
So. That must mean that if one was to keep the iteration state within the object itself, then the object must be governed by some manner of unlimited counter as well...

IDEA: use the InfiniteCounters there instead of the IterArrays [that being, base the IterArrays on them]; 
The InfiniteCounters, then, are based on generators and inverse-generators. 
So, the IterArray just becomes the wrapper around them! 
Beautiful! 

TODO: for mr. flesh, pray implement...
// ? Question: should the GeneralArray thingy even HAVE all that separation onto 2 indexgenerator systems???
// * Current decision: no, they are [in the class case, that being the general one] united. But, in special cases [like .map, for instance...], instead allows for this kind of diversity.

// ? Question: what about the conversions? Which element of this structure should they relate to? 
// * Pray think on it... [Then, implement?] 

IDEA [about conversions]: 'conversion' (or 'convert') would, too, become a general algorithm. 
It would work like so: takes in corresponding read()/write() + the other arguments for the GeneralArray and then 're-creates' the array using it. 
Returns the re-created version with the new structure defined specifically by these two. 

IDEA : about the UnlimitedString; 
One doesn't like the in-strings and all that work with them. 
One'd like it to be done in terms of something else. 
The UnlimitedString could work like so, for instance, have an UnlimitedMap of some objects [numbers, for intance] to "characters" [1-lengthed strings within a given encoding or any other things...], 
a 'comparison' by which to '.get()' them, and an UnlimitedArray of the symbols from the UnlimitedMap.keys(); 
Then, one has the 'read' and 'write' procedures + all the stuff from the UnlimitedArray, which would work just the same except for 1 difference - the input and output are converted using the 
string's unlimited map in question. 
TODO: wonderful! pray implement...


IDEA: the InfiniteNumber: as a math-expression.js-type generator-function defining an infinite sequence of objects with a defined order on them in terms of the index of the position, 
wrapped into a templated object, which itself is a result of an InfiniteNumber() function call;  
So, for instance, one would have something like: 

0011235423624678679235956791... 
10089704590434750296493034024059...

The last one being greater. 
One could add signs for this sort of stuff, as well as dot-positions; 
The thing itself would be defined as an infinite (that being, unlimited) GeneralArray instance, with addition, multiplication, inverses [both additive and multiplicative] implemented on it; 
Indexes used would [could, that being] also be unlimited; 

// ! The only Problem with this is such: the defined sequences always have the maximum being one defined by the function (i) => (n-1), where 'n' is the number of symbols used for the representation of the sequences...

[for example, for decimal with symbols 0123456789, it'd be: 999999999999....]