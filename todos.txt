This is a temporary todo list. 
It gets changed actively. 

1. math-expressions.js 1.0: 

    Current Idea for a list of kinds of things to add (create more things for it): 
    1. types - everything related to types [includes all insofar added and all yet planned]; 
        has got statistics, numeral-related stuff, counters, orders, linear algebra stuff, infinite types, extension of the oldapi to infinite types (everything)
        ? question: should one not create sub-divisions inside it?
    2. util - various utils; 
    3. ... (perhaps, something related to equation-parsing? some in-built things?)
    4. algorithms - as says, different algorithms; 
        Has in itself sorting algorithms, other interesting ones...
        ? again: question about sub-namespaces...
    5. ... (something that is an extension of the idea of drawing and the current concept for the Surface class)  
    
    // TODO: rework this part of the first TODO...
    New things to add: 

        1. ideas of TrueInteger and all other "True" number classes (those that are capable of theoretically storing arbitrarily large values -- user's machine is the only limit) from an unpublished project;
        2. ideas of Order[s], OrderedArray, IterableSet, generators; note: TypeScript is bad for these things representation, its got Generics, but no templates;
        3. new sorting algorithms, for generalized versions of orders; more new funny/interesting algorithms; 
        4. The previous log, logHack functions (they are quite nice...) and other stuff from 'that other project'

    Old things to (maybe?) delete/rework: 

        1. Tests class (change the naming convention, add Wikipedia links so that one could understand which test is meant, some have such similar names; maybe add a few more interesting things there...)

            note: 

        2. arrayEquality -- rework, generalize to being &&-composition of equality of each of the given arrays pair-wise...
    
    The published thing should be useable as a Deno dependency (via `import`) -- check that it does, indeed, work like one (just in case)...
        
2. Documentation

    Rewrite the introduction; 
    Separate it onto different versions, including <= 0.8 (for each one separate, maybe based on the old readme.md files)

    (Suggestion?) Separate both old and new ones onto classes and functions; 

    Change the in-editor JSDoc documentation...

3. New things: 

    Create a great deal of new definitions; 
// TODO: create ideas for what new stuff to add...

4. Finish the package.json (particular: fix the keywords); 

	Add more keywords related to what kind of stuff does the library actually have: 

		1. primes; 
		2. infinite; 
		3. [after the 1.1 version] 'returnless' and also 'continuation[-style]'; 
		4. numbers; 
		5. vectors; 
		6. graphics; 
		[and so on...]

	Maybe pick some better words, dunno...

5. (IDEA; Under question for an implementation) Develop a shorthand-language for various syntax algorithmical syntax constructs ; 

    Make it a part of a library...

    For example: f(a);(b) would be "if a, do b": 
    There could be references and things... 
    Write it using one's (for now unpublished) library for parsing things...


6. (reminder) Before the 1.0 release, pray clear all the TODOs, ?sand !s; 

    All the privatenotes, as well as this very list...
	Also, the "^ IDEA" notes [once they've been implemented and all saved within some particular commit...]; 

	ALSO: the *s - check them all out, take out all the unwanted ones, perhaps make others into something else? 

7. Change the comments for the introduction ("this is the source code and copyright" bit at the beginnings of both files); 

8. Decide the look of the comments... (Stars, no stars? other symbols/colors there...) And which ones to keep (so that the code looks navigable...)

9. Change all the desired so JS-classes for the function-object combinations: 

    This is mimicking the behaviour of templates: the abstraction turns into a 
    sequence of "layers" to get called, each allowing for an extension of the thing in question;
    For example, one such is used to generate different "classes" (in truth, constructor functions...)

10. Rename the _ver10.mjs into "math-expressions.js" after having tested it properly; Replace the old file; 

11. Pray add a good descripttion to the GitHub repository...
12. Create each new version of the library in such a fashion as for it to be complete: there is not one thing that could not be done with it and which would want to be done by oneself...;

13. Add the tests to the 'test' folder

    Update the old examples (make them more comprehensible) and create (much) more new ones; 
	Use the examples as tests [id est, here they're equivalent]; 
    
14. Conduct regular note-cleanups, checking if anything has become redundant.

15. IDEA: change the argument order for many of the functions (make them more intuitive;)

    For starters -- the new api, repeatedApplication, for example.

16. [Plan] for 1.1. - [along with many other new things,] restructure the library by adding the 'returnless' version of all the previous and new APIs; 

	Continuation-passing style. 
	JS programs with infinite stack. 

	PROBLEM: THE MATH-EXPRESSIONS.JS INFINITE TYPES ARE [sort of] USELESS....
	The problem is largely such: recursive calls; 
	The stack of JS is limited...
	SO, though the 'programmatically unlimited' types are [in truth] not STRUCTURALLY unlimited, 
	they ARE limited by the V8 [or whatever other engine's] stack [which is only finite]. 
	So, for instance, with the numberCounter method, one certainly (and that is a very rough upper bound only) won't be able to store numbers beyond 

		(2**53)*((2**32 - 1)**(14000))

	Which is a lot, but not programmatically unlimited. 
	With infinite stack and continuation-passing style, one could achieve TRULY programmatically unlimited types + infinitely-stacked JS programs. 

	SOLUTION: the math-expressions.js will [already after the 1.0 release; there'll be a special library for that...] a 'returnless' API for that sort of stuff; 
	will get tied to the corresponding library, so that user have a way of accessing it more directly from it... 

17. TODO: cleanup; 
	
	Do a major file cleanup within the project's tree...

	1. delete the 'images.txt'
	2. delete the 'privatenotes.txt' [only after having completed them... Until then - let they stay '.gitignored'...]