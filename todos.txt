// TODO: this todo list is outdated. It is in reworking proces... As the package progresses, one's views of it and the goals change; 

1. math-expressions.js 1.0: 

    Current Idea for a list (create more things for it): 
    1. types - everything related to types [includes all insofar added and all yet planned]; 
        has got statistics, numeral-related stuff, counters, orders, linear algebra stuff, infinite types, extension of the oldapi to infinite types (everything)
        ? question: should one not create sub-divisions inside it?
    2. util - various utils; 
    3. ... (perhaps, something related to equation-parsing? some in-built things?)
    4. algorithms - as says, different algorithms; 
        Has in itself sorting algorithms, other interesting ones...
        ? again: question about sub-namespaces...
    5. ... (something that is an extension of the idea of drawing and the current concept for the Surface class)  
    
    // TODO: rework this part of the first TODO...
    New things to add: 

        1. ideas of TrueInteger and all other "True" number classes (those that are capable of theoretically storing arbitrarily large values -- user's machine is the only limit) from an unpublished project;
        2. ideas of Order[s], OrderedArray, IterableSet, generators; note: TypeScript is bad for these things representation, its got Generics, but no templates;
        3. new sorting algorithms, for generalized versions of orders; more new funny/interesting algorithms; 
        4. The previous log, logHack functions (they are quite nice...) and other stuff from 'that other project'

    Old things to (maybe?) delete/rework: 

        1. Tests class (change the naming convention, add Wikipedia links so that one could understand which test is meant, some have such similar names; maybe add a few more interesting things there...)

            note: 

        2. arrayEquality -- rework, generalize to being &&-composition of equality of each of the given arrays pair-wise...
    
    The published thing should be useable as a Deno dependency (via `import`) -- check that it does, indeed, work like one (just in case)...
        
2. Documentation

    Rewrite the introduction; 
    Separate it onto ORIGINAL (before 0.8), FINITE and INFINITE sections; 

    Separate the new one onto namespaces; 
    Separate the old one onto classes and functions; 

    Change the in-editor JSDoc documentation...
    Fix presence of the inappropriate (id est, simply unwanted) comments; 

3. New things: 

    Create a great deal of new definitions; 
// TODO: create ideas for what new stuff to add...

4. Examples: 

    Rewrite the old examples (make them more comprehensive) and create more new ones; 

5. Finish the package.json (particular: fix the keywords); 

6. (IDEA; Under question for an implementation) Develop a shorthand-language for various syntax algorithmical syntax constructs ; 

    Make it a part of a library...

    For example: f(a);(b) would be "if a, do b": 
    There could be references and things... 
    Write it using one's (for now unpublished) library for parsing things...


7. (reminder) Before the 1.0 release, pray clear all the TODOs, questions and stars unrelated to the 1.1. code-updating procedures...

8. Change the comments for the introduction ("this is the source code and copyright" bit at the beginnings of both files); 

9. Reminder (code-rework) -- after the 1.0 release, pray do work with the other libraries, publish them and then use as dependnecies (their previous versions) of this one in the 1.1 release; 

    This'll simplify much of the code enormously; 

10. Decide the look of the comments... (Stars, no stars? other symbols/colors there...)
11. Create a sketch of a code organization on which one would be content: 

    At the moment of first writing the todo, it is: 

        1. All things related to finite native JS types go to "finite";
        2. All thing related to infinite derived types go to "infinite"; 
        3. All things that are universal and work for both the kinds of types go to "infinite"; 
        4. The original math-expression api is within the "math-expressions.mjs"
    
    IDEA (currently chosen): 
        Move it all back to the "math-expressions.mjs" file, but separate the infinite 
        into the "infinite" object (within are classes, functions and other things...) from all other things, 
        and let the finite keep where it is + get added to itself new things (namely, the new finite methods...)

        Let also, the universal methods be stored with the finite ones; 

12. Change all the desired so JS-classes for the function-object combinations: 

    This is mimicking the behaviour of templates: the abstraction turns into a 
    sequence of "layers" to get called, each allowing for an extension of the thing in question;
    For example, one such is used to generate different "classes" (in truth, constructor functions...)

13. Compare the newer "finite.mjs" with "math-expressions.mjs" and decide... 

    What to add, what to delete, what to change and so on...
    