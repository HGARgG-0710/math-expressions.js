This is a temporary todo list. 
It gets changed actively. 

1. Ensure the possibility of the thing to work with both Deno and NodeJS;        
2. Documentation

    Separate it onto different versions, including <= 0.8 (for each one separate, maybe based on the old readme.md files)
    Change immensely the general style of the in-editor JSDoc documentation...

3. [REMINDER] Finish the package.json and the rest of the package-organization related things; 

	This includes the GitHub repository organization (things like description, for instance...); 

4. (IDEA; Under question for an implementation) Develop a shorthand-language for various syntax algorithmical syntax constructs ; 

    Make it a part of a library...

    For example: f(a);(b) would be "if a, do b": 
    There could be references and things... 
    Write it using one's (for now unpublished) library for parsing things...


5. (reminder) Before the 1.0 release, pray clear all the TODOs, ?sand !s; 

    All the privatenotes, as well as this very list...
	Also, the "^ IDEA" notes [once they've been implemented and all saved within some particular commit...]; 

	ALSO: the *s - check them all out, take out all the unwanted ones, perhaps make others into something else? 

6. Change the comments for the introduction ("this is the source code and copyright" bit at the beginnings of both files); 

7. Decide the look of the comments... (Stars, no stars? other symbols/colors there...) And which ones to keep (so that the code looks navigable...)

8. Change all the desired so JS-classes for the function-object combinations: 

    This is mimicking the behaviour of templates: the abstraction turns into a 
    sequence of "layers" to get called, each allowing for an extension of the thing in question;
    For example, one such is used to generate different "classes" (in truth, constructor functions...)

9. Add the tests to the 'test' folder

    Update the old examples (make them more comprehensible) and create (much) more new ones; 
	Use the examples as tests [id est, here they're equivalent]; 

10. IDEA: change the argument order for many of the functions (make them more intuitive;)

    For starters -- the new api, repeatedApplication, for example.

11. [Plan] for 1.1. - [along with many other new things,] restructure the library by adding the 'returnless' version of all the previous and new APIs; 

	Continuation-passing style. 
	JS programs with infinite stack. 

	PROBLEM: THE MATH-EXPRESSIONS.JS INFINITE TYPES ARE [sort of] USELESS....
	The problem is largely such: recursive calls; 
	The stack of JS is limited...
	SO, though the 'programmatically unlimited' types are [in truth] not STRUCTURALLY unlimited, 
	they ARE limited by the V8 [or whatever other engine's] stack [which is only finite]. 
	So, for instance, with the numberCounter method, one certainly (and that is a very rough upper bound only) won't be able to store numbers beyond 

		(2**53)*((2**32 - 1)**(14000))

	Which is a lot, but not programmatically unlimited. 
	With infinite stack and continuation-passing style, one could achieve TRULY programmatically unlimited types + infinitely-stacked JS programs. 

	SOLUTION: the math-expressions.js will [already after the 1.0 release; there'll be a special library for that...] a 'returnless' API for that sort of stuff; 
	will get tied to the corresponding library, so that user have a way of accessing it more directly from it... 

12. TODO: project tree cleanup; 

	1. delete the 'images.txt' [after having completed all inside it]
	2. delete the local 'privatenotes.txt' [only after having completed them... Until then - let they stay '.gitignored'...]

13. [ACROSS-THE-JS-PROJECTS TODO...] : use the 'a in b' instead of 'b[a] !== undefined'; 

	As one had suspected, the latter don't actually work in the cases when the 'undefined' is used as a value...

14. IDEA: for the package.json and 'npm run test', of the package make the following work:
	Let the 'test' script that is being run accept an argument of an array of test files/cases to be executed, 
	which will then be used to produce the appropriate testing procedure [namely, run the appropriate files]; 
	If none are passed, then all the tests are executed in the alphabetic order...; 

15. Later - add better support for platform- and standard-dependent aspects of the library. 
	For instance, the native ecmascript String uses the UTF-16 standard. 
	The JS has within the String class methods for more intimate working with it.

16. Things to add to the library [for the later versions]: 

	16.1. Statistics - the decision was made because the present 'statistics.mjs' was simply way too thin and skinny to be added. 
		Even though that is (historically), is also the origin of the library, it must be first properly revised and (especially) finished - new methods, new things; 
	16.2. Number sequences; 
		Amongst them - fibonacci, Lucas numbers, primes, and so on...
	16.3. Linear algebra; 
	16.4. (Possibly, possibly not, a very general thing) Theorems/axioms/object-properties (things for the automatic theorem prover software implementations); 
	16.5. (Possibly?) Combinatorics? 
	16.6. (Possibly???) Extend the 'types' further - return back to the MultiInfiniteCounter and MultiGeneralArray ideas...; 