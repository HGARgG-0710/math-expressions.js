This is a temporary general project todos list. 
It gets changed actively. 

1. Ensure the possibility of the thing to work with both Deno and NodeJS;

	Similarly, ensure the presence of CommonJS modules... (distinction upon '.mjs' and '.cjs' extensions + TypeScript...); 
	The thing ought to be a NodeJS module which is runnable by Deno (meaning, adhereing to the Node16 standard, at least); 

2. Documentation

    Separate it onto different versions, including <= 0.8 (for each one separate, maybe based on the old readme.md files)
    Change immensely the general style of the in-editor JSDoc documentation...

3. [REMINDER] Finish the package.json and the rest of the package-organization related things; 

	3.1. This includes the GitHub repository organization (things like description, for instance...); 
	3.2. IDEA: for the package.json and 'npm run test', of the package make the following work:
			Let the 'test' script that is being run accept an argument of an array of test files/cases to be executed, 
			which will then be used to produce the appropriate testing procedure [namely, run the appropriate files]; 
			If none are passed, then all the tests are executed in the alphabetic order...;

4. (reminder) Before the 1.0 release, pray clear all the TODOs, ?sand !s; 

    All the privatenotes, as well as this very list...
	Also, the "^ IDEA" notes [once they've been implemented and all saved within some particular commit...]; 

	ALSO: the *s - check them all out, take out all the unwanted ones, perhaps make others into something else? 

5. Work on the comments separately: 	
	5.1. Decide their looks, style (stars? No stars?), average compactness/largeness, and other minor particularities; 
	5.2. Redo the introductions for the code files and modules (relook through them most throroughly and affect to one's liking...);  

6. Add the tests to the 'test' folder

    Update the old examples (make them more comprehensible) and create (much) more new ones; 
	Use the examples as tests [id est, here they're equivalent]; 

7. [Plan] for 1.1. - [along with many other new things,] restructure the library by adding the 'returnless' version of all the previous and new APIs; 

	Continuation-passing style. 
	JS programs with infinite stack. 

	PROBLEM: THE MATH-EXPRESSIONS.JS INFINITE TYPES ARE [sort of] USELESS....
	The problem is largely such: recursive calls; 
	The stack of JS is limited...
	SO, though the 'programmatically unlimited' types are [in truth] not STRUCTURALLY unlimited, 
	they ARE limited by the V8 [or whatever other engine's] stack [which is only finite]. 
	So, for instance, with the numberCounter method, one certainly (and that is a very rough upper bound only) won't be able to store numbers beyond 

		(2**53)*((2**32 - 1)**(14000))

	Which is a lot, but not programmatically unlimited. 
	With infinite stack and continuation-passing style, one could achieve TRULY programmatically unlimited types + infinitely-stacked JS programs. 

	SOLUTION: the math-expressions.js will [already after the 1.0 release; there'll be a special library for that...] a 'returnless' API for that sort of stuff; 
	will get tied to the corresponding library, so that user have a way of accessing it more directly from it... 

8. Complete the 'images.txt' [after having completed all inside it, or regarded as undesired]

9. [ACROSS-THE-JS-PROJECTS TODO...] : use the 'a in b' instead of 'b[a] !== undefined'; 

	As one had suspected, the latter don't actually work in the cases when the 'undefined' is used as a value...

10. Later - add better support for platform- and standard-dependent aspects of the library. 
	For instance, the native ecmascript String uses the UTF-16 standard. 
	The JS has within the String class methods for more intimate working with it.

11. Things to add to the library [for the later versions]: 

	11.1. Statistics - the decision was made because the present 'statistics.mjs' was simply way too thin and skinny to be added. 
		Even though that is (historically), is also an origin of the library, it must be first properly revised and (especially) finished - new methods, abstractions - things;
	11.2. Number sequences; 
		Amongst them - fibonacci, Lucas numbers, primes, and so on...
	11.3. Linear algebra; 
	11.4. (Possibly, possibly a separate project, a very general thing) Theorems/axioms/object-properties (things for the automatic theorem prover software implementations); 
	11.5. (Possibly?) Combinatorics? 
	11.6. (Possibly???) Extend the 'types' further - return back to the MultiInfiniteCounter and MultiGeneralArray ideas...; 
	11.7. Real-numbered functions - introduce various implementations of general real-valued functions computations with unlimited precision; 
		Things that are elementary, give a way for their composition production; 
		Then, allow for such infinite composition, and consequently - partial computation of them too...; 
	11.8. Real - class of real numbers, based off rational functions over which nth digit is to be calculated; 
		Recently, done some derivation (still checking for correctness), seem to have found a proof for the 
		statement that there is a general algorithm using which any real number's arbitrary digit in any number base
		can be calculated (+ definition for the thing in question). Originally was planned for the v1.0, but now letting it rest for slightly later; 
			The problems with adding it to the v1.0 are: 

				1. It's complex, and in that harshly contrasts with some of the library's current tools. 
				2. [Reason for 1.] For it to become simple, one requires a proper and widely extensive API for working with abstract functions and expressions, conversion between them, and so on... 
					It's currently lacking, would take much time to implement. 
					This library's version has already been in development for over a year, so one decided to do this well later, and for now merely keep a reminder.
				3. Not quite sure about the implementation details due to the lack of proper limitation on the number of steps for the algorithm's execution: 
					Namely, the theorem guarantees that the amount of steps of the algorithm IS finite, but how large - not specified. 
					Generally, it is impossible to do so, due to the fact that one CAN explicitly construct functions, for which the algorithm will run for arbitrarily long time. 
					
					So, one would either have to set a certain kind of conditional 'restriction' upon the implementation, or leave the matter of some small details 
					to the user's discretion (namely, the user would have to personally verify how fast does the given rational function converge on average, and whether 
					it is applicable); 
				4. The derivation in question may contain mistakes (plus, at the time that this is being written, it's only at the sketch stage of readiness), 
					and later simplified/studied further. 

			Thus, a decision has been made to think about it further in the v1.1; 

	11.9. RealEquality - a variable equality involving real numbers; 
		Was originally a part of the package as a far simpler finite-decimal-rational-only version of 2 sides, but due to violent generalization, was remade into a purely
			Real multi-sided equality implementation. Unfortunately, due to the 'Real' not being quite suitable for this particular release, it won't be possible to implement 
				the thing in question within the v1.0 either. 
		Later, add. Intended for analysis of approximation data for various function-equalities over reals; 
		Supposed to boast a generalization for an arbitrary syntax (user-given parsing functions) + another one - for arbitrary sequences of objects in possession of 
		properties same as Real (see if that's really necessary, or they're all isomorphic and, thus, representable via Real itself). 

	11.10. InfiniteNumber - an InfiniteArray-based arbitrarily-based TrueInteger infinite sequence defined by the user's function (like InfiniteArray); 
		Supposed to implement (minimum, later - add new beautiful creative ideas here): 
			1. addition (infnum)
			2. additive inverse ()
			3. multiplication ()

		Undone for several reasons: 

			1. The methods 2. and 3. require more mathematical derivation (which will take time and which, at the moment of writing the thing in question, one does not yet possess); 
			2. Too short methods list due to the previous difficulties with InfiniteSeries API, and abstract-Function-treatment in the library generally [which, again, will take time, and currently not having it]. 
			3. 

		
		THIS INCLUDES THE PREVIOUS InfiniteSum (deleted from v1.0 due to the definition domain issues); 

12. MAJOR NAME GENERALIZATION: allow for arbitrary 'isword', 'classref', and other such expressions in the library methods: 

	Most of them make use of the predefined defaults only, forcing the user to either rewrite the code manually for this trivial matter, 
	or to use the default package code convention; Not good at all. 
	(Note: one can do it using further 'templates'; Additionally, fix the default recurring template names like 'genarrclass', 'tintclass', 'icclass', 'comparison' and so on...);

13. Dubious but interesting structural ideas that may have a return: 

	13.1. 'leftovers' - the ending argument of every method and every class that allows to extend its possibilities; 
		Currently - no application + trashes the code for no apparent reason. 
		If return, only after v1.1. and when working on generalization of things. 
			Reconsider their deletion, plus (generally, the way that the templates work). 
				For some methods (like 'GeneralArray.permutations' and 'GeneralArray.intersection'), they work quite well as 'template-substitutes', 
				and so shall be kept (even in the v1.0); 