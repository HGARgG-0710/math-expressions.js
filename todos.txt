// TODO: this todo list is outdated. It is in reworking proces... As the package progresses, one's views of it and the goals change; 

1. math-expressions.js 1.0: 

    Current Idea for a list of kinds of things to add (create more things for it): 
    1. types - everything related to types [includes all insofar added and all yet planned]; 
        has got statistics, numeral-related stuff, counters, orders, linear algebra stuff, infinite types, extension of the oldapi to infinite types (everything)
        ? question: should one not create sub-divisions inside it?
    2. util - various utils; 
    3. ... (perhaps, something related to equation-parsing? some in-built things?)
    4. algorithms - as says, different algorithms; 
        Has in itself sorting algorithms, other interesting ones...
        ? again: question about sub-namespaces...
    5. ... (something that is an extension of the idea of drawing and the current concept for the Surface class)  
    
    // TODO: rework this part of the first TODO...
    New things to add: 

        1. ideas of TrueInteger and all other "True" number classes (those that are capable of theoretically storing arbitrarily large values -- user's machine is the only limit) from an unpublished project;
        2. ideas of Order[s], OrderedArray, IterableSet, generators; note: TypeScript is bad for these things representation, its got Generics, but no templates;
        3. new sorting algorithms, for generalized versions of orders; more new funny/interesting algorithms; 
        4. The previous log, logHack functions (they are quite nice...) and other stuff from 'that other project'

    Old things to (maybe?) delete/rework: 

        1. Tests class (change the naming convention, add Wikipedia links so that one could understand which test is meant, some have such similar names; maybe add a few more interesting things there...)

            note: 

        2. arrayEquality -- rework, generalize to being &&-composition of equality of each of the given arrays pair-wise...
    
    The published thing should be useable as a Deno dependency (via `import`) -- check that it does, indeed, work like one (just in case)...
        
2. Documentation

    Rewrite the introduction; 
    Separate it onto different versions, including <= 0.8 (for each one separate, maybe based on the old readme.md files)

    (Suggestion?) Separate both old and new ones onto classes and functions; 

    Change the in-editor JSDoc documentation...

3. New things: 

    Create a great deal of new definitions; 
// TODO: create ideas for what new stuff to add...

4. Examples: 

    Update the old examples (make them more comprehensible) and create (much) more new ones; 

5. Finish the package.json (particular: fix the keywords); 

6. (IDEA; Under question for an implementation) Develop a shorthand-language for various syntax algorithmical syntax constructs ; 

    Make it a part of a library...

    For example: f(a);(b) would be "if a, do b": 
    There could be references and things... 
    Write it using one's (for now unpublished) library for parsing things...


7. (reminder) Before the 1.0 release, pray clear all the TODOs, questions and stars unrelated to the 1.1. code-updating procedures...

8. Change the comments for the introduction ("this is the source code and copyright" bit at the beginnings of both files); 

9. Decide the look of the comments... (Stars, no stars? other symbols/colors there...) And which ones to keep (so that the code looks navigable...)

10. Change all the desired so JS-classes for the function-object combinations: 

    This is mimicking the behaviour of templates: the abstraction turns into a 
    sequence of "layers" to get called, each allowing for an extension of the thing in question;
    For example, one such is used to generate different "classes" (in truth, constructor functions...)

11. Compare the newer "finite.mjs" with "math-expressions.mjs" and decide... 

    What to add, what to delete, what to change and so on...

    Suggestion 1: After it is done, pray rename the newer "finite.mjs" into "math-expressions.mjs" and delete the other file...
    Suggestion 2: still keep the older api in a separate file, keep them away with namespaces, keep supporting the old one and fix errors in it...

12. Pray add a good descripttion to the GitHub repository...
13. Create each new version of the library in such a fashion as for it to be complete: there is not one thing that could not be done with it and which would want to be done by oneself...;

14. IDEA: create a 'test' folder, for tests; then, after having written those, pray do make the 'example.mjs' import them all, thus running them!

    This will both solve the problem of 'waiting too long to test one particular thing whilst centralizing all tests within "examples.mjs"' 
    and also allow to have a simple and direct way of looking at "how does this one particular thing "x" work like?"; 

    Suggestion: one could add them all manually within the script, or [currently chosen; more elegant] just save all the names of all imports and things within a certain file, 
    then read from it within 'examples.mjs', then import all things using some particular API that allows to import from a variable path, equivalent to the way 'import' does it (running it) 
    [for example: https://github.com/ModuleLoader/es-module-loader]

    Alternative suggestion [of all three currently prevalent; don't require any side-api or a separate file]: instead of using an API and 'implicitly' running the tests, one could just walk the directory and then run each and every file using 'execSync(`node ${filename}`)'; 
    