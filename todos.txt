1. Right, this thing has not been touched in more than a year. 

For now, Mr. Body is a tad tired, so only making this one TODO... 
Later will deal with it...

Time to do something about it; 

    1.1. Using TypeScript

        Rewrite the thing into TypeScript; 

    1.2. Documentation

        Separate the functions/classes onto categories; 
        Get rid of the funny introduction

    1.3. Remaking of the math-expressions.js: 

        The new math-expressions.js (1.0) should not have backwards-compatibility; 
        It's written in TypeScript; 
        Should use namespaces for the separation of different abstractions; 

        Current namespaces: 

            1. linear (for linear-algebra-related stuff; add more of it, btw): 
            2. statistics (for statistics-related-stuff; )
            3. util (for various nice functions like generate, dim or copy)
            4. algorithms (various algorithms)
                4.1. algs.sort (sorting algorithms, not only for number arrays; generalized)
            5. abstract (for the new ideas);  
                5.1. counters (for counter-related stuff); 
                    5.1.1. numerals (stuff for number-to-InfiniteCounter transitions and also the numbers system creation things)
                5.2. orders (for order-related stuff); 
            6. numbers (for the older number-related things)
            
            (Question: where do all the old things go?)
            They would do perfectly with the newer objects (InfiniteCounter-based ones;)...
            DECISION: goes to "numbers"; there, in every function the InfiniteCounter is used by means of transforming the user's input via "abstract.counters.numerals"; 
            Then, all the initial library code gets rewritten (that is, generalized, the code itself is the same); 
            
        
        New things to add: 

            1. ideas of TrueInteger and all other "True" number classes (those that are capable of theoretically storing arbitrarily large values -- user's machine is the only limit) from an unpublished project;
            2. ideas of Order[s], OrderedArray, IterableSet, generators; note: TypeScript is bad for these things representation, its got Generics, but no templates;
            3. new sorting algorithms, for generalized versions of orders; more new funny/interesting algorithms; 
            4. The previous log, logHack functions (they are quite nice...)

        Old things to (maybe?) delete/rework: 

            1. Tests class (change the naming convention, add Wikipedia links so that one could understand which test is meant, some have such similar names; maybe add a few more interesting things there...)
            2. exp function (either expand it enormously, or delete entirely; this thing can be so much more beautiful...)
            3. arrayEquality -- rework, generalize to being &&-composition of equality of each of the given arrays pair-wise...
            4. repeatedArithmetic -- if one does happen to generalize it much, pray let one make it repeatedOperator; 

    1.4. "S" for "Style": 

        Create more generalized "style" for the project; 
        things like "copy" should be documented and defined to be general; 
        What can be generalized gets generalized; 
        
    1.5. New things: 

        Create a great deal of new definitions; 
        Follow the Projects within the 
    
    1.6. Examples: 

        Update examples in accordance with all this stuff...

2. Fix the keywords in the package.json; 

3. PROBLEM : there is a difficulty with the package; 

    It is such: what does one do about the default numbers? 
    Should the library even be supporting them now? 
    It does have a far more unlimited alternative -- the InfiniteCounter; 
    Should one remove them completely, then? 
    The previous functions get rewritten for the numbers, et voila; 

    But wait: there's a problem with doing that too: it is the arabic numerals; 
    The library should have a good way of representation of them; 
    There should be ways to convert an arabic numeral into an InfiniteCounter (but not conversely); 
    Thus: to the list of things to be added, the numerals add; 

4. PROBLEM: types; 

    For the large part, the library had been ignoring them; 
    As shining examples: the Vector, Matrix and RectMatrix classes; 
    They have the methods that are supposed to exist only in the case of number being the type; 
    but they STILL do exist in the others; 

    Solution: based on the passed `type` parameter, one would decide whether one such is present or not...
    (In a different language, one would just use a bloody tempalate literal as an object, but never mind about that now...)

5. Name of the package; 

    Considering the major changes... 
    It seems inappropriate; 
    Feels too narrow...

    Ideas for a new name: 

        1. expressions.ts

    Will do the next thing: publish first as math-expressions.js 1.0, then deprecate this thing, 
    publishing a new version of the thing as a new package (this is already for the expressions.ts 1.1); 

    I'm now thinking...
    Would it not be a better idea for oneself to deprecate the 0.8 thing, then? 
 
    (About changing the name) On the other hand... There is still statistics, and a lot of other things too; 

    So, no, "expressions.ts" certainly don't do...
    One wants a different name, one that would outline both the origin of the package and its destination (that is, far greater diversity and generality); 
    For now, the current title is good. 
    Later will create some other one, probably...

INDEPENDENT NOTE: Funny. The more I use types, the less I start to like them as a way of limitation and the more I start to like them as a mean of conversion between shapes...

6. Develop a shorthand-language for various syntax algorithmical syntax constructs ; 

    Make it a part of a library...

    For example: f(a);(b) would be "if a, do b": 
    There could be references and things... 
    Write it using one's (for now unpublished) parser.(..) library...

7. IDEA: let the math-expressions.mjs file stay, but be reformed as an import, becoming the "old" API, whilst the main.ts will be the "new" API; 

    Two objects "oldapi" and "newapi" would get imported from the main file; 
    The original math-expressions.js gets rewritten into TypeScript to keep all the behaviour; 
    The only incompatibilities of the math-expression since version 1.0 is the matter of the imports: they'd have to be changed; 
    One would just add 2 lines:

        import { oldapi } from "math-expressions.js"
        const {(list of the used stuff)} = oldapi

    This way, there'd never be such a striking dissimilarity with the math-expressions.js 0.8 with the 1.0 and later versions, 
    Mr. Body wouldn't deprecate the package or change the name, whilst making both a thing; 

    Even better, the old version (oldapi), may still be supported! Get updates, new things and whatnot...
    Beautiful; so happy about this decision...

8. Before the 1.0 release, pray clear all the TODOs, questions and stars unrelated to the 1.1. code-updating procedures...
9. Make sure that the library is acceptable to a Deno compiler (that is, that it would generate as few errors and warnings as possible); 

    The module must be importable by means of deno's 'import {...} from "npm:..."'

10. Change the comments for the introduction ("this is the source code and copyright" bit at the beginnings of both files); 
11. Change the package.json "version" field (always almost forgetting before the release...)