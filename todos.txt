This is a temporary general project todos list. 
It gets changed and revised actively. 

1. Documentation

    Separate it onto different versions, including <= 0.8 (for each one separate, maybe based on the old readme.md files)
    Change immensely the general style of the in-editor JSDoc documentation...

	NOTE: add also the alerts regarding speed of DeepArray (note that it is very-very poor); 

2. [REMINDER] Finish the package.json and the rest of the package-organization related things; 

	2.1. This includes the GitHub repository organization (things like a proper description, for instance...); 
	2.2. IDEA: for the package.json and 'npm run test', of the package make the following work:
			Let the 'test' script that is being run accept an argument of an array of test files/cases to be executed, 
			which will then be used to produce the appropriate testing procedure [namely, run the appropriate files]; 
			If none are passed, then all the tests are executed in the alphabetic order...;

3. Redo the introductions for the code files and modules (relook through them most throroughly and affect to one's liking...);  

4. [Plan] for 1.1. - [along with many other new things,] restructure the library by adding the 'returnless' version of all the previous and new APIs; 

	Continuation-passing style. 
	JS programs with infinite stack. 

	PROBLEM: THE MATH-EXPRESSIONS.JS INFINITE TYPES ARE [sort of] USELESS....
	The problem is largely such: recursive calls; 
	The stack of JS is limited...
	SO, though the 'programmatically unlimited' types are [in truth] not STRUCTURALLY unlimited, 
	they ARE limited by the V8 [or whatever other engine's] stack [which is only finite]. 
	So, for instance, with the numberCounter method, one certainly (and that is a very rough upper bound only) won't be able to store numbers beyond 

		(2**53)*((2**32 - 1)**(14000))

	Which is a lot, but not programmatically unlimited. 
	With infinite stack and continuation-passing style, one could achieve TRULY programmatically unlimited types + infinitely-stacked JS programs. 

	SOLUTION: the math-expressions.js will [already after the 1.0 release; there'll be a special library for that...] a 'returnless' API for that sort of stuff; 
	will get tied to the corresponding library, so that user have a way of accessing it more directly from it... 

5. Things to add to the library [for the later versions]: 

	5.1. Statistics - the decision was made because the present 'statistics.mjs' was simply way too thin and "skinny" to be added. 
		Even though that is (historically), is also an origin of the library, it must be first properly revised and (especially) finished - new methods, abstractions - things;
		New things to add to it (besides the already present): 
			1. regression analysis tools implementation; 
	5.2. Number sequences; 
		Amongst them - fibonacci, Lucas numbers, primes, perfect numbers, and so on...
		[One general method to be implemented - InfiniteUntil(ic, f, predicate) - will get all the objects of 'f(i)' of possession of predicate 'predicate', can be implemented via InfiniteArray]; 
	5.3. Linear algebra; 
	5.4. (Possibly, possibly a separate project, a very general thing) Theorems/axioms/object-properties (things for the automatic theorem prover software implementations); 
	5.5. (Possibly?) More combinatorics? 
	5.6. (Possibly???) Extend the 'types' further - return back to the MultiInfiniteCounter and MultiGeneralArray ideas...; 
	5.7. Real-numbered functions - introduce various implementations of general real-valued functions computations with unlimited precision; 
		Things that are elementary, give a way for their composition production; 
		Then, allow for such infinite composition, and consequently - partial computation of them too...; 
	5.8. Real - class of real numbers, based off rational functions over which nth digit is to be calculated; 
		Recently, done some derivation (still checking for correctness), seem to have found a proof for the 
		statement that there is a general algorithm using which any real number's arbitrary digit in any number base
		can be calculated (+ definition for the thing in question). Originally was planned for the v1.0, but now letting it rest for slightly later; 
			The problems with adding it to the v1.0 are: 

				1. It's complex, and in that harshly contrasts with some of the library's current tools. 
				2. [Reason for 1.] For it to become simple, one requires a proper and widely extensive API for working with abstract functions and expressions, conversion between them, and so on... 
					It's currently lacking, would take much time to implement. 
					This library's version has already been in development for over a year, so one decided to do this well later, and for now merely keep a reminder.
				3. Not quite sure about the implementation details due to the lack of proper limitation on the number of steps for the algorithm's execution: 
					Namely, the theorem guarantees that the amount of steps of the algorithm IS finite, but how large - not specified. 
					Generally, it is impossible to do so, due to the fact that one CAN explicitly construct functions, for which the algorithm will run for arbitrarily long time. 
					
					So, one would either have to set a certain kind of conditional 'restriction' upon the implementation, or leave the matter of some small details 
					to the user's discretion (namely, the user would have to personally verify how fast does the given rational function converge on average, and whether 
					it is applicable); 
				4. The derivation in question may contain mistakes (plus, at the time that this is being written, it's only at the sketch stage of readiness), 
					and later simplified/studied further. 

			Thus, a decision has been made to think about it further in the v1.1; 

	5.9. RealEquality - a variable equality involving real numbers; 
		Was originally a part of the package as a far simpler finite-decimal-rational-only version of 2 sides, but due to violent generalization, was remade into a purely
			Real multi-sided equality implementation. Unfortunately, due to the 'Real' not being quite suitable for this particular release, it won't be possible to implement 
				the thing in question within the v1.0 either. 
		Later, add. Intended for analysis of approximation data for various function-equalities over reals; 
		Supposed to boast a generalization for an arbitrary syntax (user-given parsing functions) + another one - for arbitrary sequences of objects in possession of 
		properties same as Real (see if that's really necessary, or they're all isomorphic and, thus, representable via Real itself). 

	5.10. InfiniteNumber - an InfiniteArray-based arbitrarily-based TrueInteger infinite sequence defined by the user's function (like InfiniteArray); 
		Supposed to implement (minimum, later - add new beautiful creative ideas here): 
			1. addition (infnum)
			2. additive inverse ()
			3. multiplication ()

		Undone for several reasons: 

			1. The methods 2. and 3. require more mathematical derivation (which will take time and which, at the moment of writing the thing in question, one does not yet possess); 
			2. Too short methods list due to the previous difficulties with InfiniteSeries API, and abstract-Function-treatment in the library generally [which, again, will take time, and currently not having it]. 
		3. A dependant upon the exactly same derivation as the 'Real'. 
		
		THIS INCLUDES THE PREVIOUS InfiniteSum (deleted from v1.0 due to the definition domain issues); 

	5.11. NAryArray (s) classes, and their arithmetic: 
		Add the bitwise operators to the 'variables.udefaultTable', based upon the special case of a new class NAryArray (based off an 'n' - InfiniteCounter), 
			which is a GeneralArray-wrapper, filled with n-bits, that interact with one another by means of predefined operations 
				(which themselves, are just a generalization of the binary bitwise-operators...); 
			
	5.12.? Integral/Differential Calculus (on real-valued functions): 
		The issue with adding an implementation of this is that the library does not boast a general definition of a limit. 
		The solution to the problem of defining the derviatives/antiderivatives in a desirable fashion would be: 

			1. Creating 'approximation-up-to' functions based off a definition of a derivative/integral, namely, approximating the value of the derivative 'up to some point of proximity' (difficulty arises when finding consequent derivatives); 
			2. Creating a set of 'rules' for elementary functions, by means of which they are integrated/differentiated (difficulty arises due to limitedness of approach); 
		
		The first one is currently preferred...

6. Dubious but interesting structural ideas that may have a return: 

	6.1. 'leftovers' - the ending argument of every method and every class that allows to extend its possibilities; 
		Currently - no application + trashes the code for no apparent reason. 
		If return, only after v1.1. and when working on generalization of things. 
			Reconsider their deletion, plus (generally, the way that the templates work). 
				For some methods (like 'GeneralArray.permutations' and 'GeneralArray.intersection'), they work quite well as 'template-substitutes', 
				and so shall be kept (even in the v1.0); 
			
		IDEA: bring them back as a special case of a concept of 'ArgumentSignature' wrapper for functions - a special object, which creates certain objects 
			(that are given specific pattern-defined locations in the function's arguments upon calling), 
				that explicify the process of setting certain given arguments (effectively, the current TEMPLATEs, but generalized); 
			The TEMPLATE macro could also go under the knife, be replaced with a Template class, which may become the special case of ArgumentSignature; 
			(Or Templates would get a different generalization? [that being, they would remain as-are currently, but be simplified and made more general?]); 
	6.2. 'transforms.mjs' - a file with various transformations upon the library objects that may come in useful 
		Originally boasted a 'noTemplates' method, that'd return the version of the 'instance()' call without the need to do '.function().function', 
		Ended up being way too thin to be added to the package in a full capacity.
		Similarly, the 'instance()' method got deleted for no wanted use could be found for it... (although, the idea does sound slightly promising, once the according object-form manipulation procedures have been implemented on an alias-level...); 

7. General matters left until v1.1: 
	7.1. TEMPLATEs state - whether '.function()' should be kept or left out of the user's scope; 
		The question relates to the fact that, while the changes to the templates in question that the second-level '.template' field provides are either too general (read 'f'), or too brisk (read 'word'), 
			they DO allow for vast library extension by means of function-wrappers and semantic-changing (and making the macro in question SUPERBLY useful for such things...); 
		Due to the fact that this is not the originally intended purpose of the many of the package's code components, the '.function()'s were taken out, 
			but this matter remained (for the most part) unanswered - SHOULD THEY REMAIN? 
	7.2. Should 'math-expressions.js' split into several libraries? 
		In particular, should 'macros' be made a separate npm package? While they do happen to have been meant for 'math-expressions.js', their usage is far-extending. 
		More than that, they are also: 
			
			1. thematically independent (and thus, can be wanted by a user for completely different reasons from that of the 'math-expressions.js' rest of the contents); 
			2. ~20 times slimmer than the rest of the library [and so, if the rest is unwanted, have to be used in this fashion...]; 

	7.3. Hardcore refactoring - there were some minor, but somewhat unambigious possibilities for refactoring left untouched within the current release. 
		The 'v1.1.' is supposed to bring those back to consideration.
	7.4. Related to the 'TEMPLATE.function' question - optional names. Allow for user-defined names for class instances [namely, the active usage of 'classref', 'isname' and so on... Currently, they are not used, just sort of 'hang' there...];
	7.5. Edge cases handling - due to urgency, one don't have enough time to fix all the wanted issues regarding the edge cases, so (in the end) only the most essential pieces of the library have this issue dealt with...
	7.6. Far more widespread usage of forms: 
		They can be used to generalize vast swarthes of repeating algorithms for different recursive data structures. 
	7.7. Fix the TEMPLATEs semantics: 
		They're unnecesserily complex, exceedingly buggy, barely serve the purposes of the library in question and (worst of all) lack single form in handling of the same operations. 
		Do hardcore refactorings + generalize where possible (then, in the uses, utilize the special case)...

		Pay particular attention to the 'counters', and the usage of 'aliases.native.const' for 'this'-binding functions...
		Also - the classes, and the way that the 'edge cases' are handled - unacceptably dirty and particular (need generality, like with the rest of the project). 
	7.8. Add more means for working with strings... - in particular the strings functions, their formatting (examples are throughout the library - for instance, the 'readable'...); 
	7.9. IDEA: Interfaces! 
		The issues connected with arbitriety of names could be a result of mixing the functionality of templates 
			[function self-referenece + convinient-recursion-semantics + connection of data] with purely conventional issues like those of names. 
		For their handling, INTERFACES can be created - they are nothing more than (conceptually, the structural complexity of the actual implementation/first-sketch may increase...): 


			// ? Add error handling for 'n'? (Then, it will also have a 'restricting' quality + make it optional then...)
			// ? Add the additional template layer (or turn this into an 'isthis: true'-kind of template?) for 'names' [Allows to change the stuff on the go...]?
			export const Interface = TEMPLATE({ defaults: { n: 1 }, function: function (names = alarray.native.generate(this.template.n)) { return function (...args) { const R = {}; for (const x of this.template.names) { R[x] = args[i] }; return R } } })
		
		It generalizes many of the library's concepts, in particular, allowing for a convinient mean of handling varying property names (by means of saving 'n' and 'names', one can obtain precisely the shape of the object of desire - the only essential issue is keeping it all somewhere); 
		Its' expansion also gives way to refactoring of many other, more complex name-involving cases (such as classes methods, for instance?); 
			Particularly interesting cases would be those that'd allow for Interfaces that return a TEMPLATE instead of a function for simple object-construction based off given property lists. 
				(Regular 'template-function'-named TEMPLATE itself would then be just a special case of Interface, with the corresponding names given...); 

		Using HIERARCHY+"isthis: true" can give one a truly great degree of freedom in changing the names of the same structures (and, effectively, allowing for re-usage of theirs...); 

		The only real difficulty afterwards become the already allocated objects from the previous versions of the Interface in question (namely, their reliance upon names that had been given before and their ultimate uselessness); 
		One could make a '.map' method for creating a new Interface that would have different names (or, again, 'switching' classes...); 

		The library would, then, utilize the Interfaces on LITERALLY EVERY step, thus achieving the name-independence... 
		(AND completely generalizing all the structures present within it, allowing for a far barer and more abstract expression of the ideas desired...)

		Instead of '.map', one could use the plain 'object' methods. The only true difficulty becomes deciding where to store the names; 
		Due to the fact that each property of 'Interfaces' has a different meaning, names must be distinguishable; 
		So, one could have the following (again, crude sketch, final version will probably differ): 

			export const Named = Template({defaults: {names: []}, function: function (names = this.template.names) {
				return Interfaces({n: names.length}).function(names)
			}}).function	

	7.10. Leaks! 
		Check the library for possible memory leaks (in particular, everything related to 'this.this.this' and recursive classes); 
		Generally, optimize it memory-allocation-wise (see if there are any issues related); 

		Note: seem to have found a leak - with the 'this.this.this' process; 
			THERE IS NOT A GOOD DEFINITION FOR RESETTING THE VALUE OF 'THIS.THIS.THIS' IN A RECURSIVE CLASS! 
			One additionally may require the change of classes, and so forth, and so forth, and so forth - all the referenced bits of it; 
				Problem is - they're non-dynamic, so due to this errors can occurr...; 
	
	7.11. Library porting. 

		Despite its conceptual beauty and usefulness, the library's main resources are stuggling enormously due to the fact that it is implemented in JavaScript, 
		or, more particularly, IT CANNOT BE USED PROPERLY (due to how long it takes for functions to run)... 
		A both: 

			1. More optimization of the current implementation; 
			2. An execution environment of greater performance; 
		
	7.12. States!

		The idea for the State class is, effectively, such (generalize from native JS numbers...): 

			export const State = TEMPLATE({
				defaults: {
					init: 0
				}, 
				function: function() {
					return (TEMPLATE({
						defaults: { curr: this.template.init }, 
						function: function () {
							return this.curr++
						}
					})).function().function
				}
			})
		
		They are just counters-based functions with no arguments that can get passed around. 
		This way, one can define infinite constructions, while also hiding their contents (and, thus, generalizing, allowing work with infinitely complex structures...); 

		They are extremely useful for creation and then consequent re-updating/refreshing (see, for instance, React Hooks...); 
		Especially useful in terms of graphs, and other places which allow for function-arguments to be evaluated (IN v1.1., POPULARIZE THEM HEAVILY...); 

	7.13. Generalization/Alias-elementarization-deconstruction of counters? 
		Due to the appearence of State in the v1.1. of the library, one may consider generalizing counters to a bunch of functions needed for connection of different kinds of objects... 
		For this, one may want to use various numeric/array functions (Real-based) to establish a structure 
			(for instance, an array of [0, 1, ..., 9], in which the "d_pi(i)"'th element (where 'd_pi(i)' is the i'th digit of pi in decimal) is equal to 82), and so on...	
		
		This way, one may want to create a specialized 'Counter' class for it... (although, there is a GENERATOR macro in place already... Consider how to organize...)
		Alternatively, one may want to consider a potential finite set of various special cases of functions, from which any manner of counters can be constructed (using 'composition' and their permutations); 

	7.14. Property- and elementary-transformation-oriented programming: 

		During the course of development, many a time did it occurr that one was faced a special case of the following general programming concept: 

			Having an object, a set of elementary transformations, and a property, to which the given final transformation (a composition of the given elementary transformations)'s value must abide, 
				one can define a new object - the result of the given transformation. 
			By means of using various such non-elementary transformations, one can cause different 'versions' of the same object. 
		
		In essence, just a restructuring/generalization of the 'function/method/predicate' and 'problem/solution' concepts using purely functional and programmatic terms. 

		The v1.1. version is supposed to also extend (greatly) the elementary-alias-capabilities of the package from the functional-programming-style perspective, 
		and particularly this construction. 

		Here's an example of a first incomplete basic implementation sketch: 

			export const toProperty = TEMPLATE({
				defaults: {
					property: alinative.function.const(true), 
				}, 
				function: function (solution) {
					return composition(FunctionCall(solution.copy((f) => (x) => !this.template.property(x) ? f(x) : x)))
				}
			}) 

		Using States, one could define dynamic predicates (change of which could align with the functions given to the toProperty), also one could extend 'property' and basic function structure in numerous ways...
		Slight issue with this general template is that the task of ensuring the "correctness" of the solution lies entirely on the user and does not (generally) prove to be a trivial matter. 
		Ofttimes, the library-user may have to spend time on implementation of particular aliases themselves, SO: 

			Additionally, create more new aliases for different kinds of function-composition/"solution-construction" (for varying kinds of structures)...; 

		This way, the previous example checked for accordance to the property on each step. One may (instead) define array-based solution-schemes like such 
			(use arguments for more complex structures of FunctionCall); 
		One could also generalize the 'scheme' as a part of the 'toProperty' definition, and then just use the desired one...

		Due to the library's style, solutions to certain computational mathematical problems can be expressed very fluently, for instance (sketch, actual code probably requires a TrueInteger conversion): 

			// ^ IDEA: add (somewhere) to the project's repository, a file with such highly-abstract mathematical computational-problems-solutions-expressions use-cases (the elegancy of it is absolutely beautiful... All that is really required for the solution of these things now is the appropriate hardware...); 
			const naturals = InfiniteArray().class()
			const primes = InfiniteArray().class().subarr(isPrime) // infinite array of all the primes (ordered by size from smallest-to-largest); 
			const perfect = InfiniteArray().class().subarr(isPerfect) // infinite array of all teh perfect numbers (ordered by size, smallest-to-largest); 
			// ... and so on...
		
		The 'property-oriented' programming would allow one for greater reliance on contents and, hence, advanced closeness of style with the mathematical computational issues of such nature, 
			as well as software for automated theorem-proving; 

		This way, all that the 'toProperty' really is, is just a collective decomposition of a very general class of functions (property-establishing ones), 
			and then - generalization of the repeating element + replacement of non-repeating ones with the aliases. 
		
		That - is the "height and essence" of the library's programming style...; 

		Also, ALL of the methods receive a powerful generalization in terms of working with 'particular values'; 
		From now on (v1.1) - all the methods use property-predicates TO THE MAX. For instance, all the collection searches (indexesOf, linear and so on...) 
			use predicates. One NEVER assumes a usage of one PARTICULAR predicate. Same goes for classes and their methods (good example - GeneralArray, bad example - UnlimitedString); 

	7.15. Refactoring. 

		During testing and consequent code-review, various (A LOT OF) new refactoring possibilities revealed themselves. 
		Due to scheduilng matters, however, one does not feel it desired to include them into v1.0, but instead leave for v1.1.	
	
	7.16. UnlimitedString.print(); 

		Previously, the library had included an attempt for a simple printing function for UnlimitedStrings. 
		However, though well-intended, it was poorly implemented from the organization- and domains- points of view...
		Ideas for re-introduction in v1.1: 

			1. Add as a method of UnlimitedString (and not have it appear anywhere else); 
			2. Make environment-independent, allowing for arbitrary printing functions (meaning - this is a either a separate in-class template, or a method relying upon class's template...); 
			3. Possible generalization? (look further...)
		
	7.17. Output-Readable Structure-Representation: 

		Generalization of the 12.16. issue (UnlimitedString.print()) - adding interfaces that would allow to output arbitrarily large 
			structures in a readable (with 'readable' being here a term-variable) format, namely, general replacement for things like: 

				const genarr = GeneralArray(...).static.empty()
				console.log(genarr.array)

		For, due to the specifics of the '...' template, the formats for arrays would differ violently, while 
			the essential nature (the Interface) of theirs still remains the same. The output ought to be completely representative
				of this, despite the size-unlimitedness requirement. 

	7.18. OPTIMIZATION: 

		By far, one of the weakest points of the library is the optimization matters - namely, the following: 

			a(c.f())
			return b(c.f())
		
		Where, c.f() can be saved into a variable. 
		Issue is, due to the generality of the interfaces implemented, the user may often find want and need to create 'nonstandard', exotic, dynamic and changing 
			instances of classes considered, and, thus, cause the simplification of using a variable (for reducing performance time) 
				to cause the code in question to become effectively invalid. 

		Consider optional allowing to use 'static' memorization of certain things throughout, 
			which (by default) will be off. 

		Additionally, some of the methods and algorithms implementation may (most probably, do) have some room for optimization/improvement (especially, memory-wise). 
		This has to be checked throroughly as well...

		ALSO - on the general speed. JS seems to be a really terrible choice for implementing something like that (in the sense of performance); 
		Seek ways to speed up the library ANYHOW AT ALL...
		Work on the general structure (without loss of generality...), create implementations of yet untried by self methods of optimization, 
			[MOST IMPORTANTLY - consider how to optimize the work with recursive objects]
		
		IDEA: for an optimization technique of counters: 
			One could do the following - save a Table with functions of object-values for a given pair of '(x, y)' for 'x.jumpDirection(y)'; 
			As a result, whenever one encounters an expression 'a.jumpDirection(b)' for some a,b - they're being looked up in the computed table. 
			If it's nonempty, then the computation is done from the nearest point, and the result is remembered; 
			Otherwise - do from nil, and then - remember. 
			This can (and, most probably, will, effectively), double all the used memory, but can improve the speed A LOT in applications that are 
				intense on counter usage. 
			That is ESPECIALLY useful, considering just how slow some of them are.
		
		IDEA [general]: add an option for EVERY method of the library to become a different kind of Table; 
			This will permit to speed up computations A LOT, with the cost of higher constant memory-consumption; 
			[NOTE: the remembered results can just be 'deepCopied' and released, when needed, so that is (by far) not an issue either]; 
			Similarly, for classes, types and so forth, one remembers the objects, then just copies from them, instead of re-running the actual constructor. 
			It'll be ESPECIALLY fast for apps that reuse a lot of the same objects time-wise; 
		
		IDEA [for counters]: fix all the counters that rely upon native builtin JS methods, instead replace them with faster alternatives; 
			Changing the '.push->[.length]=...' has made a noticeable difference upon performance; 
			Look for more of these...; 
			Also - rid the code of usage of methods that use allocation-deallocation; 
			List: 
				1. Replace all the Arrays.includes with 'Set.has()' (PARTICULARLY IN SIMPLE, FREQUENTLY-USED METHODS!!!)	
		
		IDEA [general]: 
			scrutinize the native datatypes usage, make everything as performant as possible...
		
		IDEA [general]: 
			Create a 'benchmarks' directory for performance testing of the library; 
			[Particular attention is to be paid to counters/InfiniteCounter performance, native object methods, ]
			Create benchmarks for BOTH memory usage and speed...

		IDEA: Generalize the process-interruption.
			Changing operations like: 

				const x = arr.filter(p)[0]
			
			To (for instance): 

				function X(p) {
					return (arr) => {					
						for (const a of arr) if (p(a)) return a
						return undefined
					}
				}
				let x = X(p)(arr)
			
			Can SIGNIFICANTLY increase productivity of code; 
			The only problem now becomes - writing things in a functional-declarative fashion, that would utilize the 
				optimization benefits of the iterative approach to such functions' definitions...
			
			In order for the general optimization to work, however, one ought to formalize it: 

				1. Implement the 'Process' class, that'd return an object; 
				2. Process object structure: 
					2.1. steps - GeneralArray of function-steps, each of which gets called in its own turn; 
					2.2. is_interrupted (for seeing, whether the previous step halted); 
					2.3. nextf(i) - function, which determines the next 'i' for the execution (element of the 'steps' GeneralArray) based on the previous i; 
					2.4. execute(i, j) - execute the process from indicies 'i' to 'j' (initial is 'i', while the final must be outside of 'j'); 
				
			This the so-long desired generalization of 'GeneralArray.loop().full()' method, with it infinite loops and complex looping patterns are particularly easily created in an object-oriented+declarative+functional paradigms...; 
			TODO: check if Process, indeed, adheres to the wished for properties; 
			One (then) rewrites the library in such a fashion so as to utilize this particular optimization technique on every-single-step-of-the-way, BUT without needing to rewrite the methods in question; 
			That (in particular), would pose a far more curious problem, as one would have to be also (somehow) specifying the particular point of exit for the function in question based on various external parameters... 
			['Process' would prooooooooooooooobably require some modification/extension...]
		
		IDEA: use Maps for all counters from 1.1. on instead of objects, and Typed arrays instead of casual arrays for 'numberCounter' (generalize the 'recursiveCounter->formCounter' accordingly...); 
			These'll be far more performant. 
			For generalization of 'numberCounter' - just allow for an arbitrary collection class in the 'recursiveCounter' via generalization of it into 'formCounter', and creation of appropriate form templates (functions that return forms based on the user's template...); 

		
	7.19. Idea of atRequest (possibly, add to v1.1...): 

		In a sense, a (generalization-of)/(similarly-structured-as) the Promises - an implementation of the 'at-request' computation: 

			// ! Object is supposed to be an Interface...
			export const atRequest = (f) => {
				let r = f
				let isComputed = false
				let computed
				return {
					get get() {
						if (isComputed)
							return computed	
						isComputed = true
						return (computed = r())
					}
					set get(f) {
						r = f
						isComputed = false
					}
				}
			}

		Gets used as 'const a = atRequest(x); a.get // somewhere else...'

		Allows to save time and resources for execution of a thing until when it is truly needed; 
		Additionally (far more beautiful), allows to make code with undefined (undeclared) variables work after they had been declared;

	7.20. Good Abstract Function types: 

		Add the Composable class implementation, which'd possess method '.compose', which would give the user the direct ability to perform function composition operation that'd return a new function. 

			// ! Very vague Sketch... (supposed to give ability to encompas addition of new values to argument lists and so on...)
			export function Composable (f) {
				const F = _FUNCTION(f) // or something...
				F.compose = function (...fs) {
					return composition(FunctionCall([this, ...fs]))
				}
				return F
			}
		
	7.21. Refactoring/generalizing the tests instances; 

		Currently, the tests are (pretty) dirtily written. They still serve the purpose, yet refactoring could (most certainly) be in place...; 
		Also - conduct corresponding procedures of 'beutification' of the tests output... (for fun!)

		Possibly, create a different package specifically for tests (that'd be based off the "math-expressions.js"'s API)
	
	7.22. More of the 'specific' types-API (and not only): 

		For instance, the entirety of the library provides merely 2 (!!!) options for an UnlimitedArray construction (LastIndexArray and DeepArray). 
		There have to be more. 

		Same goes for counters, only the arrayCounter and recursiveCounter (+its special cases) are really infinite (objCounter is just a '.reverse()' of arrayCounter...). 
		IDEA: polynomialCounter/naryCounter - effectively an orderArray, in which the values are changed in accordance to an n-ary representation of a given counter ([0] -> [1] -> ... -> [n-1] -> [0, 1] -> ... [n - 1, 1] -> [0, 2] -> ... -> [n - 1, n - 1, 0] -> [0, 0, 1] -> ...); With recursion - that being, one either applies the same pattern for recursion ([a...] -> [[a...]] -> ...), or a different one... (consider); 
		Must decide on more different 'specific' structures to use for the general library interfaces...

			IDEAS [for them]: 

				1. Arrays: 

					1.1. InArray - effectively [[[...], e2], e1]; Generalize to make an arbitrary length - this is for 'length=1': [[...], e1, e2], ...
					1.2. ReverseInArray (reverses the InArray - last elements are stored at higher levels, whilst first are - at the latter ones...); 
				
		More generally, instead of just creating more of special cases implementations, one could (and that is the FAR more preferred solution, as of present), 
			just implement general means of their construction, in particular - the usage of 'forms' + differently TEMPLATEs, with some options being extremely general; 
		The most desired option would be to do this, so that all the current 'particular' abstractions still remain, but only as aliases to the general version, whilst the 
			general version itself would be the one-single unifier of all the inner structure of theirs...; 
		
		Especially important is the presence of choice due to generalization of the algorithms - various structures of arrays will allow different operations to take lesser/greater time
			(for instance, the 'pop' operation of stack will be structurally closer to the ReverseInArray, than others); 
		Try to implement the ways of structure-based optimization, that would permit this (namely, a way to retain the optimization techniques without sacrificing the generality...); 
	
		Same applies to things like 'comparisons' - there's only 3 for the entire library. Thin. 
		Some new examples to add: 

			// NOTE: apart from any X, on which there's X[Symbol.iterator] and '.keys()', works with GeneralArrays, UnlimitedMaps and UnlimitedStrings (because, unlike valueCompare, uses 'of', not 'in'); 
			1. arrayCompare := (x, y, oneSide = false, comparison = valueCompare) => {
				// ! This can be done more compactly (without explicit remembering) using TableFunctions...
				const v = (x) => (Symbol.iterator in x && "keys" in x)
				const vx = v(x)
				if (!vx || !(refCompare(vx, v(y)))) return false 
				for (const ix of x.keys()) 
					if(!comparison(x.read(ix),y.read(ix))) return false
				if (!oneSide) return arrayCompare(y, x, true, comparison)
				return true 
			}
			// A comparison version of 'structure' without need for forms (all that's required is the '.keys()')
			2. recarrCompare := (x, y, oneSide = false, comparison = _valueCompare) => {	
				return arrayCompare(x, y, oneSide, (x, y) => comparison(x, y) || recarrComparison(x, y, oneSide, comparison))
			}
	
	7.23. Package's code Modularity: 

		Try to solve the issue that has appeared during the work on the modular aspects of the package (namely - try to 'flatten' all the imports/exports), so that 
			none need to recursively import...
		If that is (after all) not possible, keep the 'lib.mjs' as-is. 
	
		IDEA [for a solution]: use functions-wrappers and 'atRequest' all the way; 
			Similarly, wrap the entire modules into it + do the 'import's only in the scopes, where they're needed, 
				instead of importing at the highest level; 
			[Id est - use the dynamic imports - 'await import(...)', plus - adding a touch of asynchronous programming into the thing...]; 
	
	7.24. Functions as objects

		Oneself is much intruiged by the newly encountered concept of JS, which is - treatment of Functions as inheritants of Object; 
		Pray use this pattern far more extensively throughout the library in v1.1. 

	7.25. Name-abstraction: 	

		An interesting pattern that oneself has stumbled upon whilst doing the library's refactoring: 

			Having a set of classes with a same-named and same-interfaced method, define function, which invokes the method in question from the passed objects. 
			The obtained function now possesses an extended domain (in the sense of semantical applicability to a greater set of arguments), than any one of the methods
			of each of the classes (which are defined only for the instances). 

		This way, it would feel appropriate and fit to define such 'combiner-functions' within the code for style-unification purposes. 
		The only difficulty is the way that it would correlate with the Interface concept (namely, the fact that using it, there is a way to 
			create absolutely arbitrarily named methods upon objects with the exactly same interfaces/definitions), so the best (most optimal)
				solution would most probably be just adding an implementation of something like the following: 

			export const Method = (name) => (x, ...args) => x[name](...args)

		This'd allow one to do, for instance, 'Method("next"), Method("previous")' and so on, without having to bother with the restrictions upon the function signature 
			(not unless that is the desired way of handling them, that is, of course...)
		In the context of the user's application, it (at the same level as Interfaces) would permit greater diversity and flexibiilty in the final alias-space, 
			and particularly the user's decisions impact upon it (considering also the usage of the library for this purpose, that is...). 
		
	7.26. PrecomputedFunction

		A function abstract wrapper-class that looks something like this (rough sketch, the actual structure for value-storage would probably be different and more flexible than the native JS object + the '.bind', '.call' and all the other methods would be defined as well...): 

			export function PrecomputedFunction(f) {
				const owner = {}
				const nf = function (v) {
					if (!(v in owner.f.values))
						return owner.f.values[v]
					return (owner.f.values[v] = f(v))
				}
				owner.f = nf
				nf.values = {}	
				return nf		
			}

			export function TableFunction (f) {
				const owner = {}
				const nf = function (v) {
					if (!(v in owner.f))
						return owner.f[v]
					return (owner.f[v] = f(v))
				}
				owner.f = nf
				nf.values = {}	
				return nf		
			}
		
		Note: this kind of a precomputed function is ONLY useful, when there are no object-allocation operations in play under the hood (and one does not intend to keep the exactly same object in-place...).
	
		For objects [when copying and reference-independence are needed] - check each of already rememebered results for valueCompare (or a different comparison, which would be more class-neglection-oriented [THINK ABOUT WHICH ONE TO PICK...]), 
			then - copy the initial (this way, only the comparison and copying procedures actually take any time); 
		Although (truth be told), one doesn't (truly) NEED the copies of objects which are IDENTICAL in structure; 
		That being, one could do the following (maximize the memory-efficiency + add the generality): 

			1. Create a single ComparisonPool (or ComparisonMemoizer) object for the entire program; 
			2. Allocate an object within the ComparisonPool; 
			3. Use the object within the program's portion that uses the 'comparison', off which the Pool is based in order to get the object in question: 
				3.1. What the Pool does is - store an GeneralArray-representation of the structure of all the allocated objects; 
				3.2. Walk through the entire array in question, in search for the asked object for allocation: 
					3.2.1. If it's there - return the already allocated version; 
					3.2.2. If not - allocate the new object (add its ORIGINAL [no copy] to the GeneralArray of all the allocated objects), then return it (reference to it); 
			4. The ComparisonMemoizer also gets the set of functions/methods and their according names/aliases, which would be wrapped in a function of memoization: 
				4.1. One could (rather, instead) be passing an AliasSpace object, which would be composed of different kinds of aliases/names for methods/constants; 
				4.2. The AliasSpace, would itself accept the methods for definition of variables (functions, that get called to receive the value), the methods themselves - Callable-s all, and other AliasSpaces (subspaces)...
				4.3. A Callable is (effectively) a function, which is a dynamic composition of other functions (a GeneralArray of which is stored within it); 
					4.3.1. Essentially, a Callable is a single PrecomputedFunction, that is 'precomputed' in regards to values of composition-functions and the values for its 'dynamic composition array'; 
					4.3.2. A Callable 'f' can be called via 'f()' [again, it's a function]; 
				4.4. Alias-subspaces, effectively, only add the desired prefix-name to the operation of obtaining the desired name (so, they simply add another layer of abstraction, purpose lies in further structure introduction); 
				4.5. An AliasSpace itself is an Interface (so it can be mapped to a different set of names);
					4.5.1. Also - the methods of it are to be defined in such a fashion, so as to be capable of using the AliasSpace's names' list pointer, instead of particular names; 
						Note: this can allow to build far more structurally flexible programs, which would retain the EXACTLY same conceptual structure, while abstracting from the particular meanings; 
			5. All the library's elements, then (the functions) are kept as functions, to which the according wrapper can be assigned...; 
			6 [Additional]. Create some particular Memoizer-versions of the library (namely, create examples of storage of the entire library as a ComparisonMemoizer + an Alias Space...); 
		
		Using these several steps, one creates a single system, in terms of which all the library's operations can be generalized purely from the style standpoint, 
			plus allowing for elimination of the precomputation as a separate step over a united structure; 

		BIG NOTE: 
			for optimization purposes - some of the 'comparisons' and the trivial/(incredibly light)/basic functions WILL NOT get the PrecomputedFunction structure embedding, due to the fact of it being (generally) quicker/(more memory performant)
				to simply compute them, then to go over the entirety of their values list; 
		ANOTHER BIG NOTE: 
			See, whether there are any cases, when the 'unoptimized' (without the lookup table) versions of methods/functions are actually quicker; 
			If (sometimes) that is the case (see when, how they change/progress) - 
	
	7.27. Matters of data-exposition and encapsulation within the library's design: 

		Frequently, one stumbled upon cases when it was not quite clear whether to let some piece of function's definition (its' template) 
			remain open (to change, reading) or closed (whether to expose it). 
		Think on it deeply for each and every single case in the library... (for now, the rule of thumb is to generalize as hard as possible). 

	7.28. Type-assertion

		Another major feature that the library is lacking desperately is type-assertion (or an alternative form of type-checking/type-conversion). 

		There isn't a general 'Type' structure and, hence, no way at all to keep track of which type does a certain object belong to (except using a case-by-case basis of '.is' implemented in all the CLASSes); 
		There ought to be such API, namely - to allow for ensuring actual properties of objects. 

		IDEA for an implementation - use 'typeConst' for individual type-identification (this is perfect and absolutely foolproof, as the reference to the type isn't stored anywhere but in the memory allocated for the identifier, it can't be meddled with.)
			ALSO, one could possibly allow for multi-typing, so instead of carrying around a 'type: object' property on self, the instance'd have 'type: object[]', and check if 'instance.types.includes(x.type)'; 
			The '.is' structure, hence, would be separated from CLASSes, and instead given to Types (hence, decomposing the macro further...). 
		
		Also, one could tinker with the type-inheritance idea. So, for example (sketchy pseud-code...): 

			Type<x>.inherit = function (y = []) {
				return Type<[...y, x]>
			}
		
		As a simple example. 

		NOTE: as more and more one does work on the project's testing, the more dire does the wish for Type-assertion present self...; 
		NOTE: reminder - a TYPE CONVERSION IS ESSENTIAL! Similiarly, the ability to control the precise type-functions for in-/out- of a given class/type method..; The type structure ought to be separate from the Class structure, yet be capable of working with it..; 

	7.29. Uniting 'macros' and types: 

		One was (for some time)	 considering getting rid of the 'macros' part of the package, decomposing all that is inside it heavily, and putting inside the 'types'. 
		Also, the concept of a 'macro' is far less consistent with the library's essential image and nature, than that of a type. 
	
	7.30. Native JS Generators

		Was thinking of generalizing the shape of a native JS 'Generator' function (the 'function*' syntax). 
		One could simply re-create its shape, but the proper 'yield'-imitation additionally requires the preservation of the variables' states. 
		(An extremely curious case to implement generally)

		An example of an implementation attempt (without some of the fields of the 'Generator'): 

			export function Generator (f) {
				const varspace = {}
				let i = 0
				let state = false
				return () => {
					next() {
						const fr = !state ? f(i++) : [undefined, state]
						return { value: fr[0], done: (state = fr[1]) }
					}, 
					return() {
						state = true
					}, 
					throw(e) {
						throw e
					},
					// ... here, the rest of it goes ...
				}
			}
		
		The downside of this implementation is that, while preserving the pattern desired, it still requires some code-changes in order to work with already created 'function*' functions. 
		Also, it won't work with the current CLASS macro definition...
	
	7.31. Domain extensions? 

		Due to the vast changes in the library's general style, oneself was considering for its domains to change as well. 
			For now, while defining and enabling the ability to interact with general types, its "most direct/immediate" applications do not travel far beyond stated in the README.md file. 
			However, during the writing of the tests, the desire appeared to refactor them (which cut down the lengthiness of the file and added to the general readability). 
			One may want to to consider further domain extension via the alias-space (for example - testing). 

			These 'more applied' bits would adhere to the same stylistic "standard" as that set by the rest of the library and will serve, largely, as a mere addition related to the rest of the thing. 
		
	7.32. Programming Style

		Some of the objectives related to the ensuring of the unity of style of library were not yet achieved (due to size and time matters). 
		The v1.0 has some wonderful examples of what is desired 
			(composition-only functional-like dataflow, in which objects are treated as objects/passables/data themselves,
				and every function is either just a composition of other functions, or is elementary and is given as an alias within the 
					context of the package...), 
		but also that of uncompleted bits and parts; 
	
	7.33. Debugging

		This, largely, relates to the 'printing' API part of the note in question. 
		The process of debugging apps written with the usage of the library's current typesystem is an absolute pain. 

		It ought to be fixed. 
		Create proper printing and debugging APIs for it (ones that would permit accessing particular pieces of type's data, without the necessity of knowing the entirety of it...); 
		[Also - create a complete debugger - withe namespaces and so forth. DO NOT RELY UPON console.log. THERE MUST BE PROPER REPRESENTATION MEANS IN PLACE INSTEAD OF THIS...]
	
		Things to be present in the debugging (testing) API: 

			1. A method for (explicit) generation of a type example using a 'random' function (such as, for instance, a PRNG); 
				1.1. It would take the function, then (based on the user's definition), would use it to choose one of a set of possible values (or a value fitting another, more general, given pattern); 
			2. Alias-based (as always, declarative method-system of definitions); 
			3. Ability to flexibly define various type-outputting options; 
			4. LOTS of defaults for the predefined typesystems of the library; 
			5. Ability to work with recursively defined types (example - an UnlmitedMap/GeneralArray/other-collection-class of InfiniteCounters/TrueInteger-s/other-collections); 
	
	7.34. Method signature information. 

		Another small funny thing, that'd be nice to have in the library. 
		Objects that collect/contain information regarding particular type instances that can later be used generally. 
		For instance - method signature. Given some readable signature object 'S(f)', for a function 'f', one can determine number of arguments
			and (sometimes) their types. 

		So, an example of a basic implementation sketch would be (no arbitrary number of arguments, no GeneralArrays yet): 	

			export const MethodSignature = (f, narguments = 1, types = VOID) => {
				return {	
					function: f, 
					types: is.arr(types) ? alarray.native.generator(0, narguments - 1).map((i) => types[i]) : narguments.map(types), 
					n: narguments, 
				}
			}
		
		Which can be refactored+generalized name-wise using Interfaces. 
		These things are particularly useful when dealing with methods such as 'finiteobj' frequently.
		Allows to separate the signature from actual functions, then use the data where needed, by means of connecting everything with '.map'; 

		These would be a vast generalization of what can be observed in the 'general.finiteobj' function usage (there, only 2 (4, with TrueInteger and Any types) type-generalizations are available currently...); 
		An alternative way to implement it (much more beloved by myself) is creating a new function, that'd have all the properies of the previous one attached: 

			export const MethodSignature = (f, narguments = 1, types = VOID) => {
				const nf = function (...arguments) {
					return f(...arguments)
				}
				
				for (const x in f) 
					nf[x] = f[x]	

				nf.types = is.arr(types) ? alarray.native.generator(narguments).map((i) => types[i]) : narguments.map(types)
				nf.n = narguments

				return nf
			}
		
		This way, no need to require for the MethodSignature additionally (as a separate Interface), however, it also opens possibilities to type errors introduction (due to missing signature when it is required...); 
		For that, an additional type can be created, so as to track the presence of signature and throw early; 
	
	7.35. Code Cleanup

		Besides, stylistic changes, one would love to clear all the redundant comments and all such undesired items. 
		Check for things that are redundant/over-specific, repeating definitions, delete them (after having generalized and refactored), or keep as a part of the alias-space. 

		Also - introduce global aliasing of non-generalizable, or default, naming constants (such as ["keys", "values"] for 'Object.') into the library; 
		Try to use varnames (identifiers) as much as possible and abstract from particular; 
	
	7.36. On replacing TEMPLATEs with TableFunctions: 

		The concept of templates can (largely) be replaced with 'TableFunctions', so as to reduce the memory-usage/unneeded copying, when doing: 

			templated(templateobj).function(...)

		Then, the only meaning of pre-saving would be semantical (no memory over-usage);  	
		Think deeper on the matter of precise definition (and the way that it would incorporate TableFunction);
	
	7.37. Naming conventions. 

		The "issue" of naming conventions was (still) fairly uresolved by the time that the v1.0 version was getting finished. 
		Current decisions in its regard: 

			1. PascalCase - for classes, types and other object constructors; 
			2. flatcase or camelCase for functions/methods/variables' names (with typical preference to flatcase); 
			3. RARELY use common snake_case (decide intuitively); 
			4. MACRO_CASE for macros (planned for deletion) and constants
		
		Question [1]: WHAT ABOUT LOCAL CONSTANTS? 
			They are (typically) named without much of a second thought. 
			Consider whether that is truly desirable (with the size more and more rapidly so approaching 10000+ lines of code with each new version...)
		
		Question [2]: (Possibly?) Rethink the library names; 
			Re-read through them (yet again), then pray decide...
	
	7.38. Error-handling

		This is (in effect), the expansion of the 'type-assertion' v1.1 todo; 
		Summarily, one needs: 

			1. General types-constructor for Errors; 
			2. Various frequently-appearing or just curious special cases of the constructor; 
				2.1. Note: they must be such, so as to cover the entirety of the possible issues related to the library-handling; 
					Especial attention is to be paid to the inconsistencies between the permitted/defined usage of a interface, and its actual definition (examples - missing arguments, Type-Assertions). 
			3. Ways to throw the resulting exceptions (they must be non-Error and non-throw based, to allow for usage of Interfaces... For instance, using process.exit() or Deno.exit()); 
			4. It (the final error-message) must possess a general format; 
			5. It must allow for arbitrary Callstacks; 
				5.1. For this - IMPLEMENT THE CALLSTACK STRUCTURE of a Debug module (maybe, make into another package, or make a part of the current thing...); 
			
	7.39. Recursive 'general' types and their finitization; 
		For the 'finite' function - given a function, it constructs an alterante one, which is a wrapping of the original into 
			a transform of one type into another. 

		There are two major problems with it currently: 

			1. It's not general enough - no ability to set the desired transforms; 
			2. It does not work with recursive return types; 

		The [2] is actually a special case of [1] (due to the fact that if one were to allow for arbitrary transformations, 
			an unlimitedly-recursive type-transform could be added to the desired template of 'finite' and, thus, solve the [2]); 
		
	7.40. The '.function' repetition; 
		Some templated functions (currently) have an extremely inconvinient structure, like the following - 
		
			a() - the template; 
			a()() - the template; 
			...
			a()()...() - the actual call; 
		
		Think about how they could be changed to just a 'a().function() - call', like the usual; 
		This, PARTICUARLY, relates to the mdaarrsearch.mjs functions (namely, the findDeepUnfilledArr and others);  
	
	7.41. Functional-like declarative programming and the current GeneralArray/InfiniteCounter; 

		Currently, most of their code (if one neglects the 'alias' bits), are written in a predominantly imperative/procedural styles; 
			That's not good. One would seek to rewrite them in terms of functional approach. For example: 

				InfiniteCounter.compare = (a,b) => a.equal(b) ? true : ???
			
			The proble with the further definition is that, if one was to attempt translating the thing DIRECTLY into separate function calls, 
				then they must be dependent upon one another (because, whilst one will cause infinite recursion - other will finish safely, and there is NO WAY to initially know which is which). 
			This way, one ought to give these manner of things particular attention and thought. 
			THE ONLY parts of the code in InfiniteCounter/GeneralArray that need be rewritten like that currnetly (and cause troubles)
				are loops; 

			The finite ones can be reduced to finite recursion cases. 
			However, more intricate ones (such as this) pose a little more of a conondrum. 
			Anyways, do it later. 
		
	7.42. No more 'selective' feature-addition; 

		In places such as, for instance, 'GeneralArray.loop()' (where there is ability to have 'end' as a function with dynamic value - function that returns a function), 
			one can see an example of so-called 'selective feature introduction'. 
		In short - a feature that applies to a particularly chosen class of objects/items of the library, whilst it just as well could to others, yet it doesn't. 	
		That sort of thing ought to be rooted out from the library entirely. The library must possess a singular and consistent (here - in the sense of features) style. 
				
	7.43. Non-templated classes; 

		Another observation obtained from looking more closely at 'CLASS'es - the result is ALWAYS, NECESSERILY, a template; 
		That is not (as of itself) a design limitation, however, having to do '.function()' manually does look (somewhat) ugly and unwanted; 
		In v1.1 - definitely do something about it; 
	
	7.44. About using objects as the native-JS mean of defining the library's items... 

		It's not a terribly good choice. Maps are far more suitable; 

			1. They're (generally) faster and more memory-efficient; 
			2. Allow working with non-(string|Symbol) keys; 
		
		The point 2. is ESPECIALLY important due to the matter of 'Interfaces' - one could even make names that are themselves objects using them; 
	
	7.45. IDEA: Make library objects into functions with properties, that are defined as 'a: a() = a'; 

		The beauty of the concept is that its implementation allows for creation of syntax-level compatibility layer 
			for various things, such as: 

				// For UnlimitedMap
				for (const x of a.values){...}
				// For Map 
				for (const x of a.values()){...}

		While the first piece __won't__ work for Map, the second won't work for UnlimitedMap (without introduction of this feature). 
		Adding it, however, allows to use the previous; 

		SIDENOTE 1: It could also make debugging without type-assertion and other requested library features MUCH MUCH MUCH harder due to acceptability of different syntaxes for the library's types API; 	
		SIDENOTE 2: due to limitations of native JS's objects, there exist (in particular situations) prefereable ways of working with the library's types; 
		SIDENOTE 3: after this change, the library has ("officially") deserved a status of 'function-only-consisting' ;D (because, literally, everything is a function in it...); 
	
	7.46. Computation contexts; 

		They are generalizations of 'Callable's: 

			Given an arbitrary set of argument variables, one is interested to predefinedly separate the variables into different 'computation contexts'
				(that being - ability to take a single method, then compute different arguments for its execution at different times); 
			
		The computation contexts must have the following interface on them: 

			1. merge(f, PREFERENCE)(c1, ..., cn) - merge contexts from 1 to n (ON THE SAME FUNCTION F!!!), return new one (this, effectively, merges different 'levels' of contexts into that of one, by using the 'PREFERENCE' predicate to determine which are which... If true - in a pair, first is preferred - otherwise, second);  
			2. break(c, BREAKPREDICATE) - breaks a single context into multiple disjoint ones based off BREAKPREDICATE predicate ('() => true' breaks it on each, while '() => false' does not break it at all - returns the array with the current one (Effectively, walks the array of arguments, separating one if BREAKPREDICATE(...) is true, otherwise - puts them together...)); 

		Those are EXTREMELY USEFUL generally, and particularly for things like abstraction, refactoring and asynchronous programming; 

		COMPUTATION CONTEXTS ELEGANTLY GENERALIZE THE TEMPLATES!!!!
		REPLACE/GENERALIZE IMPLEMENTATION OF TEMPLATES WITH COMPUTATION CONTEXTS!!!
	
	7.47. Make the 'Defaults' easily configurable; 

		Provide interfaces for changing their values easily (and globally); 
		Possibly, create a whole 'Space' class for that - a VariableSpace, for instance...; 
		[And have the library export various default versions with varying values for the 'Defaults']; 
	
	7.48. Testing thoroughness; 

		Some of the tests that were considered 'trivial' (such as certain checks of general structure classes implementations when using different comparisons) were skipped initially. 
		When writing tests for v1.1. and later - do no such thing...
	
	7.49. Create a separate library term for the first (zero-th) argument of the 'GeneralArray.class', and the ACCORDING MODEL-FUNCTIONS!!!

		Currently, the 'GeneralArray.class' is (extremely) under-used and is simply not good enough for actual application. 
		Problem is - there's no way to SEPARATELY create the array of the desired 'type'/'kind'/(inner '.array'-structure), and THEN pass it to the '.class'
			function. 
		Initially, the idea was to HAVE such 'array kinds/types/models', and use the GeneralArray ONLY as a way of generalizing transition between them; 
		Instead, the GeneralArray ended up 'taking the semantic reigns', and what was originally considered to be a set of specially defined array-types, that simply can use 
			the same format for transition, into a whole blown type, that 'consumed' all the representations into itself...; 

		The v1.1. seeks to remedy this. Keep the GeneralArray as a type, BUT separate the 'kinds' of arrays; 
		They must be distinct from correspondent GeneralArray classes the GeneralArray must have the 'three functions (elem, newvalue, isEnd) and property (empty)' more 'separated'
			(namely, have them separately from the rest of the stuff... - icclass, comparison, unfound, treatfinite, default); MEANING - another layer of templates (another computation layer/context...); 	
		ALSO create 'arrayTransition' function, that would allow transition from one internal type of array to another using GeneralArray; 
		ADDITIONALLY - consider separating the 'copying' procedure for array-transition, and the 'algorithms' part, that is to be used with each and every single one of the arrays...; 
			The 'algorithms' bit is intended for usage 'on' the array instances, while transition isn't (or, more precisely, it must be separate, with a local object's-method-alias); 
			ALSO-ALSO-ALSO - the 'elem/newvalue/isEnd/empty' must be in a template-like structure, while 'currindex' - in a SEPARATE FROM THE 'algorithms' PART STRUCTURE!!!! 
				Currently, it's a large mess that the gigantic 'GeneralArray' class has the access to it, while NO SINGLE ONE DEFINITION in it, apart from a very small DIRECTLY-RELATED number, 
				are actually using it; 
				RE-DO. PROVIDE ANOTHER INTERFACE LAYER! 
			
		ALSO [possibility]: 
			break down the GeneralArray on set of different Interfaces (greater structure diversity, like with 'currindex/elem/isEnd/empty'); 
			Do it the following way - re-create the implementations for the library in a semantically sound way, so that one may rewrite the thing 
				by breaking it up in a desired 'Inner-Dependency-Closed chain' of Interfaces, that the final one will be using the methods from. 
			
		NOTE: for all that to work, one needs another method - 'Interface.inherit()'; 
		[
			The Interface now has at least 2 methods beside constructor: 

				1. map(A) - returns a new Interface with the new (given) set of names; 
				2. inherit(a, A) - returns 'a' - the interface, which inherits all the things from A; 
		]

	7.50. Generalize 'composition's to work with context-ed functions...: 

		What it says in the title; 
		Sometimes, a function needed for composition is available ONLY in the context, from which the composition is being run; 
		So, one would want some AtRequest datatype specifically for representation of these situations in the library's code...; 
	
	7.51. Unelegant from type-polymorphisms standpoint-of-view code: 

		Sometimes (especially in 'low-level' places), the library requires checking the type of a primitive; 
		Those checks range from very pretty and laconic ('is.arr(x)') to slightly ugly and overloaded ('is.obj(x) && !is.arr(x)'); 
		Problem is - there are either: 

			1. Not sufficiently large number of predicate-aliases for this (which just means adding more definitions to the library); 
			2. Insufficiently great amount of variations on the native JS types' functions that would enable type-polymorphism (for instance - X: X.is(a) <-> !is.arr(a) && is.obj(a) && a); 
		
		One decides to look in the direction of '2.'; 
		Create more such examples of types, define means of quick creation of theirs (effectively - working with types as with sets: union, complement, and so forth...); 
	
	7.52. Add better support for platform- and standard-dependent aspects of the library. 
		For instance, the native ecmascript String uses the UTF-16 standard. 
		The JS has within the String class methods for more intimate working with it.
	
	7.53. Re-consider the general structures used for implementation of type-classes such as UnlimitedString, UnlimitedMap and UnlimitedSet; 

		Currently, EXTENSIONs are used; 
		However, one would love to instead use: 

			1. Template-s for the template-variables on the classes; 
			2. Interface-s for name-fluidity (and enumerations of methods); 
			3. Some 'inheritance' structure _NOT_ external to the parent classes (like the way that EXTENSION is) [a sort of 'classobj.[inherit/extend](...)' method]; 
				3.1. Subnote: The 'parent-variables' will remain, will just get treated differentl; 
			4. Treatment of EXTENSION-like parentclass-variables as a set of wrapper functions (that being - no repetition of the 'wrapper' structure in the EXTENSION '.function' constructor); 
			5. No more of 'transform's - same as 4., with 'wrappers'; 
			6. PROPER PARENT-OBJECT REFERENCING! 
				No more of the StaticThisTransform (that's the purpose it's been serving so far...); 
				There must be a general structure just for that; 
				Namely, this: 

					A = {B: {p: A, ...}}
					A.B.p == A
				
				It is encountered ALL OVER THE PLACE in the library; 
				Extremely useful construct, for which there's no simpler way in JS; 
			7. No more symbols/methods separation (generalize both, then make into one EVERYWHERE); 
			8. No more property-method separation (define special types for that, generalize, separation must be type-based); 
			9. No more 'static/methods' separation - EVERYTHING is a dynamically-obtained class instance item, that would work (depending) on the presence of such an instance or its absence (that being - ALLOW THE RUNNNING OF THE METHODS __WITHOUT__ any value for 'this' - for that, create yet anoter Interface...); 
			10. Generalization of 'recursive' - instead of behaving like a flag upon a structure for creating instances of classes, it gets its own named definition (for creation of structures that are responsible for 'this.this.this'-handling, while the Clases only unite the whole thing, by providing user with the corresponding Interfaces); 
		
	7.54. Violent usage of {}-based types; 

		Due to the fact that the lower-level information regarding the {} (such as adress and scope), 
		is hidden, it's possible to create non-compromisable implementations of type systems with their help;  
		Let this be used MOST extensively. Literally, the entire library's typesystem would be based off this allocation-uniqueness over the refCompare. 
		
		This way, one'd be able to reproducably distinct one type from another within a given typesystem; 
		Types, hence, within the given const-context, would be nothing more than a set of different 
		constructor-objects/functions/methods, to which a refCompare-unique 'type-id' has been assigned. 
		
		This way a question of an object's 'types' would become nothing more than looking up an array of different object-constants; 
		On this, the vast generalization of all already present in the math-expressions.js would be based; 

		Generally, the 'separation'	is now done ONLY via types; Inter-type operations are defined on a type level, 
		and type-inheritance is present (so as to allow for one type to have all/certain features of another); 

		A VERY general default type system is present as an export (the wide extension/continuation of the current one), 
		as well as mighty tools for creation of user-defined TypeSystems;
	
	7.55. IDEA: breaking up the math-expressions.js on a set of different derivative libraries, that would then get imported into it; 

		Break it into: 

			1. typesystems - for creating typesystems, alias systems, debugging and everything else; 
				Note: has a continuation-style version and one that is not; 
			2. abstract - a typesystem based off 'typesystem' (the current 'default'); 
				2.1. (submodule) abstract.algorithms - for algorithms for the default typesystem;
					(Here, things such as Stack, orders and such are going)
				Has a continuation-style version and one that isn't; 
	
	7.56. The general System class; Let the structures be written in an easily generalizable template-manner; 

		A System/Context would be a kind of an interface, defining a set of key-value pairs, such that 
			the values are (all) of possession of set properties (by which the system is defined); 
			Additionally, the passed values would all be functions of a context (so, their final in-context values would/could depend upon the context, to which they've been passed); 
		There'd be different kinds of in-library Systems-aliases, all based off different functions/predicates (TypeSystem, AliasContext); 
		They'd all be basd off a 'MapInteraface'-like object (Map, UnlimitedMap are examples - must be properties 'values()', 'keys()', 'set()', 'get()'); 
	
	7.57. Making the library asynchronous; 

		Re-create it to make EVERYTHING an asynchronous function; 
		Due to: 

			1. Would allow for extension of library's domains; 
			2. Would be (probably) required for the planned use of dynamic imports (to support modularity); 
			3. Would cause the library to be able to work faster in environments (use-cases) that permit asynchronous programming;
		
		ANYWAYS, DO IT. 
	
	7.58. IDEA: Caches; 

		Implement the Caches classes for the PrecomputedFunction-s and Pools; 
		They are, (effectively), a given Pool, which is used BY ALL the functions within a given context, and has a limited size; 
		This allows the user to: 

			1. Keep the performance more predicatable; 
			2. Save up memory for memoization;

		Naturally, in order to work properly, it'll need the Cache replacement algorithms implemented upon itself. 

		PROBLEM: with the memory keeping - Cache, despite having a limited amount of objects, 
			HAS TO also consider things like recursive structures, and so on, and so forth. 
			This makes it more difficult for the user to see the ACTUAL MEMORY USED FOR IT... 

			SO - pray consider how EXACTLY would one be limiting the Caches - memory-wise, or object-count-wise. 
			Also - how are the recursive objects to be cached within the Pools [are their elements to be added as well? And so on, and so forth...
				Agani - the usual 'when to copy' thing. Effectively, what one REALLY need is the ability to specify the passing structure (reference/pointer/copying/et-cetera) 
				to the FUNCTION in question (like in C++, for instance...)]? 
			
				idea: for a solution - one way to limit and control the memory usage more efficiently is separation by types (then, the problem comes down to identifying the amount of memory taken up by the particular type...); 

	7.59. BEAUTIFUL IDEA: PrecomputedCounters!

		A beautiful, universal way for creation of UNIQUE counters INSTANCES based ENTIRELY off the library concepts of Precomputation and object allocation (refCompare-unique constants)!
		Effectively, a PrecomputedCounter is a pair of fields pointing to the same PrecomputedFunction, that (on call) does the following: 

			1. If, for the given constant, a value has already been assigned, then it returns this assigned value (standard precomputation procedure); 
			2. Otherwise, ALLOCATE A NEW OBJECT, THAT GETS SAVED!
		
		This way, one can: 
			
			1. Easily create arbitrarily large cardinality-order-isomoprhic-to-integers sequences of objects; 
			2. NOT NEED TO WORRY ABOUT COPYING!!!
			3. MOST IMPORTANTLY - ________NOT_NEEEDDD_THE_RECURSION_!!!

		So, with them, one can ACTUALLY HAVE A GENERAL, NON-CPS VERSION OF THE UNLIMITED-DATA-TYPES LIBRARY CLASSES!	
		(Unfortunately, in order to make all the rest of the current API work, one still needs to re-do it in CPS, but THIS is golden!)

		For programming languages with direct access to memory allocation procedures + memory comparison + a lacking limit on the amount of 
			allowed memory for allocation (immediate usage of RAM), the concept can be implemented MOST intuitively; 
			Good examples: C/C++; 
		
	7.60. IDEA: SelectivePrecomputedFunction; 

		This is (essentially), a generalization of a 'precomputed function', which goes something like so (obviously, this is an unoptimized, and incomplete, sketch/idea but still...): 

			export const SelectivePrecomputedFunction = TEMPLATE(
				{
					defaults: {
						predicate: T
					}, 
					function: function (f) {
						const cache = {}
						return function (x) {
							if (x in cache) return cache[x]
							const computed = f(x)
							if(predicate(x)) cache[x] = computed
							return computed
						}
					}
				}
			).function
		
		Effectively, this allows to selectively cache certain objects; 
		This particular construction gives the user IMMENSE depths for optimization of their apps due to usefullness of the caching, and ability to determine the need for it arbitrarily...; 
	
	7.61. IDEA: per-object caching: 

		Create a Cache structure, which can be attached to certain Object-like structures that the library is to use as an Object/Map replacement...;
		They are (effectively) per-object caches, that would work on the entirety of the object's method set (and that all the methods would have the access to); 

		The Caches themselves would be able to access Pools (which oneself may make into a Cache itself?), and other Caches (so as to be able to optimize groups of objects in an ordered fashion...); 
	
	7.62. Reasons for library's immense slowness: 

		The first and foremost are: 

			1. The lack of caching, primarily in: 
				1.1. Models for InfiniteCounters; 
					Instead of caching the previous counter, and then doing a single call that is cached as well (and passing same counter values by reference, so that the checking is FAST), 
						one calculates ALL THE PREVIOUS NEEDED COUNTERS!!! 
					The overhead is insane. Add that to just HOW WIDESPREAD is their use throughout the library, and the efficiency lack is hardly a great surprise; 
				1.2. Models for GeneralArrays (no memoization for values of indexation); 
				1.3. Generally within any particular app (no allocation mechanism, no Caches, no Pools); 
			2. Native type inefficiecies - lack of usage of optimal types for various operations, lack of efficient time tradeoffs for type conversions; 
				An excellent example during v1.0alpha development was replacing the Array.includes with Set.has; Look for more such things. 
				Currently noticed: 
					1. 'a in object' has O(1) running time (instead of O(n) of Set.has()); 
					2. Map.has() is almost always faster than 'object' (only found exception - integer keys); 
					3. Map works with object keys, while objects - don't (conclusion - use Map-s instead of objects more predominantly); 
			3. Language of choice/runtime - NodeJS code (while CAN be optimized to work far better), is still more high level than, say, C/C++; 
		
	7.63. Add various elementary objects (extend the counters' concept); 
		An example list (those that are definitely to be included, expand it...): 
			1. Infinity, -Infinity
				The JS standard implementation of 'Infinity' from IEEE754 doesn't look all too good:
					1.797694*10**308 == Infinity
				Algebraically, 'Infinity' from the library would have properties (on a given counter's values' set): 
					x.jumpForward(Infinity) == Infinity; x < Infinity
					x.jumpBackward(Infinity) == -Infinity; x < Infinity
					Infinity.jumpForward(-Infinity) == 0; 
				This way, 'Infinity' would be the sort of 'limit point' of a counter.
				One would also love to be giving the user the power of defining the value for Infinity to be arbitrary (templated, counter-dependent), 
					so as to be capable of 'finitizing' (explicitly limiting) certain otherwise unlimited/potentially-infinite constructions; 

	7.64. IDEA: Static-valued templates: 
		
		Effectively, they are a simplification of the TEMPLATE macro to the previous (initial) level of: 

			{
				template: {...}, 
				function: function (...) {
					// ... [Direct interaction with 'this.template...']; 
				}
			}
		
		But combined with a minor quirk - a singular copy of a function is used for them (shared), which is RE-BOUND accordingly 
			(For this, create an implementation of a RebindableFunction class, which would be used by ALL instances of 'SharedTemplate' - the static-template) ; 
		This could come in handy as a: 
			
			1. powerful memory-optimization of certain types-structures-implementations inside the library; 
			2. application for a Re-conceptualization of a 'template' (example - when using templated Types, one stores the type ONCE, because that's how many there is of that type in copies, conceptually speaking, THEN - reuse it all around with a given template (to, say, find out, whether the given thing is of the type in question...)); 

		Only times when it's NOT applicable are those requiring: 

			1. Internal recursive scope-analysis of the function in question (it'll be too fluid); 
			2. Instantiation of particulars (functions), ability to distinct between templates based solely on them...; 

	7.65. IDEA: demolishing CLASSes, the '.is' and 'instanceof' for them: 

		Currently, CLASSes lack usefulness, for: 

			1. A lot of template-unrelated data gets copied EACH TIME one creates a class with new template (which can really be replaced with a Static-value (Shared) Templates - look above - with far greater efficiency); 
			2. The '.is' does not work effectively for type-assertion (so, there's NO such thing as a 'pure Type' inside the library currently - there must be...); 
			3. Classes serve n-o purpose whatsoever, save for means of storing semantically related methods (.static) and property-copying; 
			4. The structures used for Objects-definitions within the library are poorly optimized...; 
		
		Another priority of the v1.1 would be getting rid of them; 
	
	7.66. Re-conceptualization of Objects in math-expressions.js v1.1: 

		1. Use 'Map' instead of native JS 'Object'; 
		2. Make them ALL Interfaces; 
		3. [Consequent of 2., there's Interface.map] Principle of 'Every Object is a Class' - that is, the object in question can *ALWAYS* be copied as-is, and modified after (hence, the far more 'classic' OOP object-instantiation); 
		4. NO-MORE CLASSES! From now on, only types; 
		5. INTRODUCE PRIVATE PROPERTIES! 
			Things such as 'Type-Identifier' (the object used for identification of that particular class), MUST be private, 
				also - the 'Type.is(...)' function is an UnBindable (see 9.67), so that there's a way to ensure the type's consistency;
			Generally, the properites divide onto 'public' and 'private', none others; 
			IDEA: introduce a type specifically for property-identifiers; 
		6. Introduce constants (unchangeable variables)
	
	7.67. IDEA: UnBindable functions - they are those, that are permanently bound to a given spot and CANNOT BE rebound again; 

		This can be done in 2 ways at least in JS (see which one fits better): 

			1. f.bind() for a 'regular' JS function - creates a bound function that cannot be re-bound; 
			2. Is:

				UnBindable = function (f, scope) {
					return function (...args) {
						f.call(scope, ...args)
					}
				}
			
			The second one is more general, and works with library's other function-classes...; 
	
	7.68. Library restructuring. 

		The old modules set for the library no longer does the job. Outline of the previous notes: 

			Remove: 

				- macros.mjs
				- ?predicates.mjs [merge with aliases.mjs]
				- ?aliases.mjs [merge with predicates.mjs]

			Add: 

				- typesystems.mjs (might potentially become an independent package, if large enough...); 
				- function.mjs (for functions-related things - function classes such as BindableFunction, and so forth...); 
				- object.mjs (for the library's Object class [NAME IT DIFFERENTLY, SO AS TO AVOID COLLISION WITH NATIVE JS!]); 
				- type.mjs (for the Type definition); 
				- interface.mjs (for the Interface definition);
				- ?types/ (instead of the 'types.mjs', one creates this - a directory with each one definition separate... Also, many of the things from the v1.0alpha go here - altered/unaltered...); 

			Extend+Restructure: 

				- types.mjs (immensely so, possibly - decompose it? Too large a file... Yes, decompose); 
				- lib.mjs (using 'await import' and async functions, one fixes the need for this...); 
			
	7.69. IDEA: array representations for finite types; 

		Simple - effectively, they are types 'X', such that there's a set 'S_X' that: 'forall t: X.is(t) <-> S_X.has(t)'; 
		An alternative is also using the 'finiteCounters'...; 
		Just a mean for intuitive construction of finite types; 

		GENERALLY - allow for arbitrary predicate-based types (instead of ones that are 'memory-allocation'-based (which is just a special case)); 
		They would allow for functionality that the Classes sought (and failed) to provide, and that the '{}'-allocation can't. 
	
	7.70. Counter re-conceptualization: 

		They will include: 	

			1. 'comparisons' - these will NO LONGER be attached to InfiniteCounter-s;
			2. range+directions - generalization of the 2-case function-inverse (sometimes, one may want more than one inverse for more elaborate orders, create such examples, their implementations...); 
			3. counter-cache - cache with all the computed values of a counter, used only if no Pool is provided; 
			4. pool-pointer - could be Null, pointer to a single memory Pool; 
		
		Also, it'll be possible to easily construct counters using Sets (instead of writing a 'range'-functions, just give values for it in a set); 
					
8. List of general methods to be present within v1.1: 

	Some good ideas for methods that are certainly to be included into v1.1 [note - all of their appropriate versions (namely, with different orders of computation contexts, and so forth, are given there as-are...)]:

		1. methodN = (f) => (n, sp1, ..., spn, strict = false) => (...a1)_1 => ... => (...an)_n => (...args)_n => f(a1.slice(0, sp1), ..., an.slice(0, spn), ...(strict ? [] : args)) // (very) approximate pseudocode-sketch...
		2. wrapper - REWORK WRAPPERS INTO A STRUCTURE! Proper, separate self-contained ___named___ structure, that is intended more for passing around, rather than using as a template; 
			For these kinds of purposes, create cases, when same template object is NOT referenced; 
			Either a new one is created (once a thing has been edited), or it is only referenced in non-changing cases... (CREATE MEANS OF TRACKING CHANGE IN A DIFFERENT OBJECT - IF AN OBJECT HAS BEEN CHANGED, THEN ALL OF ITS 'DEPENDEES ARE CHANGED AS WELL!'); 
		3. Pair-s, Triple-s, N-Tuples: a set of abstractions' definitions for representations of arrays of static (statically known) length; 
		4. '.equal()' on EVERY class - not only just the InfiniteCounters, and number classes, collections as well - GeneralArray, UnlimitedString, ...; Due to its lacking, becomes more difficult to compare arrays directly (no alias...); 

9. Sketch-list of things to generalize (a reminder for v1.1): 
	9.1. Forms, Vector, Expression, FunctionCall, Pointer, GENERATOR <- Interface; 